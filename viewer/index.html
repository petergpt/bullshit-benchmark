<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>BullshitBench Explorer</title>
  <style>
    :root {
      --bg: #f7f4ec;
      --panel: #fffefb;
      --ink: #1f2623;
      --muted: #5f6f6a;
      --line: #d6ddd8;
      --teal: #0f766e;
      --teal-soft: #d8f3ef;
      --green: #1f9d55;
      --amber: #d88710;
      --red: #c13d36;
      --deep-red: #8a1f1a;
      --error: #4a5350;
      --shadow: 0 10px 30px rgba(20, 35, 30, 0.08);
      --radius: 14px;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      min-height: 100%;
      color: var(--ink);
      background: radial-gradient(1200px 700px at 100% -50%, #d9efe9 0%, transparent 70%),
        radial-gradient(1000px 600px at -10% 10%, #f6ecd8 0%, transparent 70%),
        var(--bg);
      font-family: "Avenir Next", "Trebuchet MS", "Segoe UI", sans-serif;
    }

    .page {
      width: min(1600px, 96vw);
      margin: 28px auto 48px;
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 18px;
      animation: fade-up 500ms ease-out both;
    }

    .page > * {
      min-width: 0;
    }

    .hero {
      background: linear-gradient(132deg, #113630 0%, #1b5f55 60%, #1d7268 100%);
      color: #f2faf8;
      border-radius: 18px;
      padding: 22px 24px;
      box-shadow: var(--shadow);
    }

    .hero-title {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .hero-title h1 {
      margin: 0;
      line-height: 1;
      transform: translateY(4px);
    }

    .hero-logo {
      width: 96px;
      height: auto;
      display: block;
      flex: 0 0 auto;
    }

    .hero h1 {
      margin: 0;
      font-family: "Rockwell", "Georgia", serif;
      letter-spacing: 0.2px;
      font-size: clamp(1.5rem, 2.5vw, 2.2rem);
    }

    .hero-subtitle {
      margin: 8px 0 0;
      color: #cde9e3;
      max-width: 920px;
    }

    .hero-link {
      border: 1px solid rgba(255, 255, 255, 0.5);
      color: #e6f4f1;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 10px;
      padding: 7px 11px;
      font-size: 0.84rem;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .hero-link:hover {
      background: rgba(255, 255, 255, 0.14);
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px;
      animation: fade-up 550ms ease both;
      min-width: 0;
    }

    .panel h2 {
      margin: 0 0 12px;
      font-size: clamp(1.28rem, 1.7vw, 1.58rem);
      line-height: 1.18;
      font-family: "Rockwell", "Georgia", serif;
    }

    .panel h3 {
      margin: 0 0 8px;
      font-size: 1rem;
    }

    .subtle {
      margin: 0;
      color: var(--muted);
      font-size: 0.92rem;
    }

    .grid-2,
    .grid-3,
    .grid-4 {
      display: grid;
      gap: 10px;
    }

    .grid-2 {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .grid-3 {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    .grid-4 {
      grid-template-columns: repeat(4, minmax(0, 1fr));
    }

    label {
      display: grid;
      gap: 5px;
      font-size: 0.87rem;
      color: #394440;
    }

    input[type="text"],
    select,
    textarea {
      border: 1px solid #bcc9c2;
      border-radius: 10px;
      padding: 9px 10px;
      font-size: 0.9rem;
      background: #fff;
      color: var(--ink);
      outline: none;
      width: 100%;
    }

    input[type="text"]:focus,
    select:focus,
    textarea:focus {
      border-color: #5aa495;
      box-shadow: 0 0 0 2px rgba(51, 129, 112, 0.14);
    }

    .button-row {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    button,
    .file-pill {
      border: 1px solid #25584f;
      background: #1d7268;
      color: #fff;
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 0.86rem;
      cursor: pointer;
      transition: transform 140ms ease, box-shadow 140ms ease, background 140ms ease;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    button:hover,
    .file-pill:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 16px rgba(27, 82, 75, 0.2);
      background: #1a665e;
    }

    button.alt {
      background: #fff;
      border-color: #bcc9c2;
      color: #30403a;
      box-shadow: none;
    }

    button.alt:hover {
      background: #f4f8f6;
    }

    .file-pill input {
      display: none;
    }

    .status {
      margin-top: 10px;
      border-radius: 10px;
      padding: 9px 10px;
      background: #eff7f5;
      color: #204740;
      border: 1px solid #c3ddd6;
      font-size: 0.86rem;
      min-height: 38px;
      display: flex;
      align-items: center;
    }

    .status.warn {
      background: #fff6df;
      border-color: #f1d79b;
      color: #744f00;
    }

    .status.error {
      background: #fdecea;
      border-color: #efc2bd;
      color: #7e1f1a;
    }

    .status.good {
      background: #eaf7ee;
      border-color: #bddfc7;
      color: #1c5f34;
    }

    .kpis {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(5, minmax(0, 1fr));
    }

    .kpi {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      background: #fff;
    }

    .kpi .label {
      font-size: 0.79rem;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .kpi .value {
      font-size: 1.35rem;
      font-weight: 700;
      letter-spacing: 0.1px;
    }

    .kpi .hint {
      font-size: 0.77rem;
      color: #667a74;
      margin-top: 2px;
    }

    .kpi.green .value {
      color: var(--green);
    }

    .kpi.amber .value {
      color: var(--amber);
    }

    .kpi.red .value {
      color: var(--red);
    }

    .kpi.error .value {
      color: var(--error);
    }

    .score-filter {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    .score-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      border: 1px solid #cbd7d1;
      padding: 6px 9px;
      font-size: 0.8rem;
      background: #fff;
      color: #32403b;
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }

    .dot.score0 {
      background: var(--red);
    }

    .dot.score1 {
      background: var(--amber);
    }

    .dot.score2 {
      background: var(--green);
    }

    .dot.score3 {
      background: var(--deep-red);
    }

    .dot.error {
      background: var(--error);
    }

    .model-toggle-grid {
      margin-top: 8px;
      border: 1px solid #d2dbd6;
      border-radius: 10px;
      background: #fff;
      padding: 8px;
      max-height: 220px;
      overflow: auto;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
      gap: 6px;
    }

    .model-toggle-item {
      display: flex;
      align-items: center;
      gap: 8px;
      border: 1px solid #d4dfda;
      border-radius: 8px;
      background: #f8fbfa;
      padding: 6px 8px;
      font-size: 0.78rem;
      color: #25453b;
    }

    .model-toggle-item input[type="checkbox"] {
      width: 15px;
      height: 15px;
      margin: 0;
      accent-color: #1d7268;
      cursor: pointer;
      flex: 0 0 auto;
    }

    .model-toggle-item.hidden {
      background: #fbf2f1;
      color: #7a322c;
      border-color: #e2c8c4;
    }

    .model-toggle-item span {
      line-height: 1.2;
    }

    .mix {
      display: grid;
      gap: 8px;
    }

    .mix-track {
      width: 100%;
      height: 20px;
      border-radius: 999px;
      overflow: hidden;
      display: flex;
      border: 1px solid #d1d9d4;
      background: #f3f6f4;
    }

    .mix-seg {
      height: 100%;
      transition: width 280ms ease;
    }

    .mix-seg.score0 {
      background: var(--red);
    }

    .mix-seg.score1 {
      background: var(--amber);
    }

    .mix-seg.score2 {
      background: var(--green);
    }

    .mix-seg.score3 {
      background: var(--deep-red);
    }

    .mix-seg.error {
      background: var(--error);
    }

    .mix-labels {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 0.8rem;
      color: #3b4b45;
    }

    .chart-block {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      background: #fff;
    }

    .chart-head {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }

    .chart-head h2 {
      margin: 0;
    }

    .chart-legend {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
      max-width: 62%;
    }

    .chart-legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      border: 1px solid #cbd7d1;
      padding: 4px 8px;
      font-size: 0.76rem;
      background: #fff;
      color: #32403b;
      white-space: nowrap;
    }

    .chart-subguide {
      display: flex;
      align-items: center;
      gap: 7px;
      flex-wrap: wrap;
      margin: 0 0 8px;
    }

    .chart-subguide-label {
      font-size: 0.75rem;
      color: #5b6f68;
      white-space: nowrap;
    }

    .chart-subguide .org-chip {
      padding: 2px 7px;
      font-size: 0.7rem;
      border-color: #d6e0db;
      background: #fbfdfc;
    }

    .bar-list {
      display: grid;
      gap: 8px;
      margin-top: 4px;
      max-height: 460px;
      overflow: auto;
      padding-right: 4px;
    }

    .launch-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      margin: 4px 0 10px;
    }

    .launch-toggle {
      display: inline-flex;
      align-items: center;
      gap: 7px;
      font-size: 0.82rem;
      color: #31433e;
      user-select: none;
      cursor: pointer;
    }

    .launch-toggle input {
      margin: 0;
      width: 15px;
      height: 15px;
      accent-color: #1f9d55;
    }

    .launch-plot-svg {
      width: 100%;
      height: auto;
      display: block;
    }

    .launch-plot-empty {
      border: 1px dashed #c6d4ce;
      border-radius: 10px;
      padding: 16px;
      color: #4f645d;
      background: #f8fbfa;
      font-size: 0.84rem;
    }

    #simpleModelBars {
      max-height: none;
      overflow: visible;
      gap: 6px;
    }

    .bar-row {
      display: grid;
      grid-template-columns: minmax(160px, 260px) 1fr auto;
      gap: 8px;
      align-items: center;
    }

    .bar-row .name {
      font-size: 0.82rem;
      line-height: 1.2;
      color: #22312c;
    }

    .bar {
      background: #f1f5f2;
      height: 16px;
      border-radius: 999px;
      border: 1px solid #d4ddd8;
      overflow: hidden;
      position: relative;
    }

    .bar > span {
      height: 100%;
      display: block;
      background: linear-gradient(90deg, #6dc5b2 0%, #1f9d55 100%);
      transition: width 280ms ease;
    }

    .bar-value {
      font-size: 0.8rem;
      font-weight: 600;
      color: #294137;
      min-width: 54px;
      text-align: right;
    }

    .stack-row {
      display: grid;
      grid-template-columns: 34px minmax(170px, 260px) 1fr;
      grid-template-areas: "rank name bar";
      gap: 8px;
      align-items: center;
    }

    .stack-rank {
      grid-area: rank;
      text-align: right;
      font-size: 0.8rem;
      font-weight: 700;
      color: #5b6c66;
      font-variant-numeric: tabular-nums;
      line-height: 1;
    }

    .stack-row .name {
      grid-area: name;
    }

    .stack-row .name.main-chart-name {
      display: inline-flex;
      align-items: center;
      gap: 7px;
    }

    .stack-row .stack-track {
      grid-area: bar;
    }

    .stack-track {
      width: 100%;
      height: 20px;
      border-radius: 999px;
      overflow: hidden;
      display: flex;
      border: 1px solid #d1dad5;
      background: #edf3f0;
    }

    .stack-seg {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      white-space: nowrap;
      font-size: 0.68rem;
      font-weight: 700;
      color: #fff;
      letter-spacing: 0.1px;
      cursor: pointer;
      transition: filter 120ms ease, box-shadow 120ms ease;
    }

    .stack-seg:hover {
      filter: brightness(0.95);
    }

    .stack-seg.selected {
      box-shadow: inset 0 0 0 2px rgba(21, 34, 31, 0.55);
    }

    .stack-seg.green {
      background: var(--green);
    }

    .stack-seg.amber {
      background: var(--amber);
    }

    .stack-seg.red {
      background: var(--red);
    }

    .seg-label {
      display: inline-block;
      padding: 0 4px;
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.35);
      line-height: 1;
    }

    .table-wrap {
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #fff;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 980px;
    }

    th,
    td {
      border-bottom: 1px solid #e2e8e4;
      padding: 8px 9px;
      text-align: left;
      vertical-align: top;
      font-size: 0.82rem;
    }

    th {
      position: sticky;
      top: 0;
      z-index: 2;
      background: #f1f6f4;
      font-size: 0.78rem;
      letter-spacing: 0.3px;
      color: #314740;
      text-transform: uppercase;
    }

    th.sortable-th {
      cursor: pointer;
      user-select: none;
    }

    th.sortable-th:hover {
      background: #e8f2ee;
    }

    .sort-ind {
      display: inline-block;
      min-width: 10px;
      margin-left: 4px;
      color: #5e736b;
      font-size: 0.7rem;
      line-height: 1;
      vertical-align: middle;
    }

    tr:hover td {
      background: #f7faf9;
    }

    .model-name {
      font-weight: 600;
      color: #1d2d28;
      line-height: 1.25;
    }

    .model-name-with-org {
      display: inline-flex;
      align-items: center;
      gap: 7px;
      min-width: 0;
    }

    .org-key-wrap {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      margin: 0 0 10px;
    }

    .org-key-wrap .small-note {
      margin: 0;
    }

    .org-key {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .org-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid #d2ddd8;
      border-radius: 999px;
      background: #fff;
      padding: 3px 8px;
      font-size: 0.74rem;
      color: #30433d;
      line-height: 1.2;
      white-space: nowrap;
    }

    .org-chip.filter-chip {
      appearance: none;
      border-radius: 8px;
      border: 1px solid #c8d7d0;
      background: #f4faf7;
      padding: 4px 9px 4px 8px;
      font-size: 0.72rem;
      line-height: 1.1;
      cursor: pointer;
      user-select: none;
      transition: border-color 120ms ease, background 120ms ease, opacity 120ms ease, transform 120ms ease;
    }

    .org-chip.filter-chip:hover {
      border-color: #98b8ad;
      background: #edf7f2;
      transform: translateY(-1px);
    }

    .org-chip.filter-chip:focus-visible {
      outline: 2px solid #5f8f7e;
      outline-offset: 1px;
    }

    .org-chip.filter-chip.is-active {
      border-color: #5f8f7e;
      background: #e4f3eb;
      color: #223831;
      font-weight: 700;
    }

    .org-chip.filter-chip.is-muted {
      opacity: 0.46;
    }

    .org-count {
      color: #60736c;
      font-variant-numeric: tabular-nums;
    }

    .org-dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
      display: inline-block;
      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.14);
      flex: 0 0 auto;
    }

    .mix-cell {
      width: 220px;
    }

    .mini-mix {
      height: 12px;
      border-radius: 999px;
      border: 1px solid #d7e0db;
      background: #f1f4f3;
      overflow: hidden;
      display: flex;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 3px 8px;
      font-size: 0.75rem;
      border: 1px solid transparent;
      font-weight: 600;
      line-height: 1.2;
      white-space: nowrap;
    }

    .pill.score0 {
      color: #7e1f1a;
      background: #fdecea;
      border-color: #efc2bd;
    }

    .pill.score1 {
      color: #744f00;
      background: #fff5dd;
      border-color: #efd89f;
    }

    .pill.score2 {
      color: #175f33;
      background: #e6f6ec;
      border-color: #bee2c8;
    }

    .pill.score3 {
      color: #591512;
      background: #f9e3e1;
      border-color: #e7b4af;
    }

    .pill.error {
      color: #27312e;
      background: #ecefee;
      border-color: #cdd4d1;
    }

    .run-meta {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 0.8rem;
      color: #334741;
      margin-top: 8px;
    }

    .run-meta span {
      background: #f1f6f4;
      border: 1px solid #d0dbd6;
      border-radius: 8px;
      padding: 4px 8px;
    }

    .compare-controls {
      display: grid;
      gap: 10px;
      grid-template-columns: 1.2fr 1fr 1fr 0.85fr 1fr;
      align-items: end;
      margin-bottom: 10px;
    }

    .compare-actions {
      margin-top: 8px;
      margin-bottom: 14px;
    }

    .compare-actions .btn-green-red-primary {
      border: 1px solid #25584f;
      background: #1d7268;
      color: #fff;
      font-size: 0.9rem;
      font-weight: 600;
      padding: 10px 16px;
      letter-spacing: 0.01em;
      min-width: 112px;
      box-shadow: 0 4px 10px rgba(17, 54, 48, 0.16);
    }

    .compare-actions .btn-green-red-primary:hover {
      background: #1a665e;
      box-shadow: 0 6px 12px rgba(17, 54, 48, 0.2);
    }

    .compare-actions .btn-green-red-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    button.alt.btn-best {
      background: #eaf7ee;
      border-color: #a7d8b6;
      color: #185232;
    }

    button.alt.btn-best:hover {
      background: #ddf2e4;
    }

    button.alt.btn-worst {
      background: #fdecea;
      border-color: #e7bdb8;
      color: #7f2a23;
    }

    button.alt.btn-worst:hover {
      background: #fbe0dd;
    }

    .question-context {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #fff;
      padding: 10px;
      margin-bottom: 10px;
      display: grid;
      gap: 8px;
    }

    .question-context .question {
      margin: 0;
      font-size: 1.2rem;
      font-weight: 700;
      line-height: 1.4;
      color: #1f2e29;
    }

    .ab-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      margin-bottom: 12px;
    }

    .all-responses-grid {
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    }

    .hidden-block {
      display: none !important;
    }

    .response-card {
      border: 2px solid #cfd9d4;
      border-radius: 12px;
      padding: 10px;
      background: #fff;
      display: grid;
      gap: 8px;
      min-height: 260px;
    }

    .response-card.score0 {
      border-color: #e4a6a2;
      background: linear-gradient(180deg, #fff7f6 0%, #fff 24%);
    }

    .response-card.score1 {
      border-color: #e7cb89;
      background: linear-gradient(180deg, #fffaf0 0%, #fff 24%);
    }

    .response-card.score2 {
      border-color: #9fd2ae;
      background: linear-gradient(180deg, #f2fbf5 0%, #fff 24%);
    }

    .response-card.score3 {
      border-color: #df9b95;
      background: linear-gradient(180deg, #fff5f3 0%, #fff 24%);
    }

    .response-card.error {
      border-color: #b9c4bf;
      background: linear-gradient(180deg, #f3f5f4 0%, #fff 24%);
    }

    .response-head {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: start;
    }

    .response-head .title {
      margin: 0;
      font-size: 0.88rem;
      color: #1d2d28;
      line-height: 1.25;
    }

    .response-head .title.model-title-with-org {
      display: inline-flex;
      align-items: center;
      gap: 7px;
      flex-wrap: wrap;
    }

    .response-text {
      margin: 0;
      white-space: pre-wrap;
      line-height: 1.44;
      font-size: 0.82rem;
      color: #233530;
      max-height: 360px;
      overflow: auto;
      border: 1px solid #dbe4df;
      border-radius: 9px;
      background: #fdfefd;
      padding: 8px;
    }

    .small-note {
      margin-top: 6px;
      color: #5b6f68;
      font-size: 0.8rem;
    }

    .drilldown-head {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
    }

    .drilldown-head h2 {
      margin: 0;
    }

    .drilldown-head .small-note {
      margin: 4px 0 0;
    }

    .drilldown-list {
      margin-top: 10px;
      display: grid;
      gap: 10px;
    }

    .drilldown-item {
      border: 1px solid #d6e0db;
      border-radius: 10px;
      background: #fff;
      padding: 9px;
      display: grid;
      gap: 7px;
    }

    .drilldown-item .meta {
      font-size: 0.78rem;
      color: #506660;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    .drilldown-item .question {
      margin: 0;
      font-size: 0.98rem;
      line-height: 1.36;
      color: #1b2a25;
      font-weight: 650;
    }

    .drilldown-item .response {
      margin: 0;
      white-space: pre-wrap;
      font-size: 0.82rem;
      line-height: 1.4;
      color: #223530;
      border: 1px solid #dbe4df;
      border-radius: 8px;
      background: #fcfdfd;
      padding: 8px;
    }

    .filters-panel {
      padding: 12px 14px;
    }

    .filters-panel h2 {
      margin-bottom: 8px;
    }

    .filters-grid {
      grid-template-columns: minmax(220px, 1.25fr) repeat(4, minmax(130px, 1fr));
      gap: 8px;
    }

    .filters-panel label {
      gap: 3px;
      font-size: 0.82rem;
    }

    .filters-panel input[type="text"],
    .filters-panel select {
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 0.84rem;
    }

    .filters-panel .button-row {
      margin-top: 6px;
      gap: 6px;
    }

    .filters-panel button {
      border-radius: 8px;
      padding: 5px 9px;
      font-size: 0.78rem;
    }

    .filters-panel .score-filter {
      margin-top: 0;
      gap: 6px;
    }

    .filters-panel .score-chip {
      padding: 4px 8px;
      font-size: 0.74rem;
    }

    .filters-panel .small-note {
      font-size: 0.76rem;
      margin-top: 4px;
    }

    .filter-meta-row {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
    }

    .filter-meta-row .small-note {
      margin: 0;
    }

    .judge-filter-row {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }

    .judge-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid #cfdbd5;
      border-radius: 999px;
      background: #f8fbfa;
      color: #2c433c;
      padding: 4px 8px;
      font-size: 0.74rem;
      line-height: 1.2;
    }

    .judge-chip input[type="checkbox"] {
      margin: 0;
      width: 13px;
      height: 13px;
      accent-color: #1d7268;
      cursor: pointer;
      flex: 0 0 auto;
    }

    .model-visibility-block {
      margin-top: 8px;
      border: 1px solid #d2dbd6;
      border-radius: 10px;
      background: #fbfcfb;
      padding: 6px 8px 8px;
    }

    .model-visibility-block summary {
      list-style: none;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.82rem;
      font-weight: 600;
      color: #32443e;
      user-select: none;
    }

    .model-visibility-block summary::-webkit-details-marker {
      display: none;
    }

    .model-visibility-block summary::before {
      content: "â–¸";
      font-size: 0.8rem;
      color: #5a736c;
      transition: transform 120ms ease;
    }

    .model-visibility-block[open] summary::before {
      transform: rotate(90deg);
    }

    .model-visibility-inner {
      margin-top: 6px;
      display: grid;
      gap: 6px;
    }

    .filters-panel .model-toggle-grid {
      margin-top: 0;
      max-height: 150px;
      padding: 6px;
      gap: 4px;
      grid-template-columns: repeat(auto-fill, minmax(210px, 1fr));
    }

    .filters-panel .model-toggle-item {
      border-radius: 7px;
      padding: 4px 6px;
      gap: 6px;
      font-size: 0.74rem;
    }

    .filters-panel .model-toggle-item input[type="checkbox"] {
      width: 13px;
      height: 13px;
    }

    @media (max-width: 1240px) {
      .kpis {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      .grid-4 {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .filters-grid {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    @media (max-width: 900px) {
      .grid-2,
      .grid-3,
      .grid-4,
      .compare-controls,
      .ab-grid,
      .kpis {
        grid-template-columns: 1fr;
      }

      .bar-row {
        grid-template-columns: 1fr;
      }

      .bar-value {
        text-align: left;
      }

      .compare-actions .btn-green-red-primary {
        width: 100%;
      }

      .stack-row {
        grid-template-columns: 34px 1fr;
        grid-template-areas:
          "rank name"
          "bar bar";
      }

      .filters-grid {
        grid-template-columns: 1fr;
      }

      .filter-meta-row {
        align-items: flex-start;
      }

      .chart-head {
        flex-direction: column;
      }

      .chart-legend {
        max-width: 100%;
        justify-content: flex-start;
      }

      .chart-subguide-label {
        width: 100%;
      }

    }

    @media (max-width: 640px) {
      .page {
        width: 100%;
        margin: 10px 0 24px;
        gap: 12px;
      }

      .hero {
        border-radius: 0;
        padding: 14px 12px;
      }

      .hero h1 {
        font-size: 1.34rem;
        line-height: 1.25;
      }

      .hero-title {
        align-items: flex-start;
      }

      .hero-title h1 {
        transform: translateY(2px);
      }

      .hero-logo {
        width: 72px;
      }

      .hero-subtitle {
        font-size: 0.9rem;
      }

      .panel {
        border-radius: 12px;
        padding: 12px;
        box-shadow: 0 6px 18px rgba(20, 35, 30, 0.08);
      }

      .button-row button,
      .button-row .file-pill {
        width: 100%;
        justify-content: center;
      }

      #simpleModelBars {
        max-height: 52vh;
        overflow: auto;
        padding-right: 2px;
      }

      .table-wrap {
        border-radius: 10px;
        max-height: 62vh;
      }
    }

    @keyframes fade-up {
      from {
        opacity: 0;
        transform: translateY(12px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header class="hero">
      <div class="hero-title">
        <img class="hero-logo" src="../docs/images/bsbench.png" alt="BullshitBench logo">
        <h1>BullshitBench: Models Answering Nonsense Questions</h1>
      </div>
      <p class="hero-subtitle">
        This benchmark measures whether models detect broken premises, call out the nonsense directly, and avoid confidently
        continuing with invalid assumptions.
      </p>
    </header>

    <section class="panel filters-panel">
      <h2>BullshitBench: Filters</h2>
      <div class="grid-3 filters-grid">
        <label>
          <span>Search</span>
          <input id="filterQuery" type="text" placeholder="Model, question id, prompt text...">
        </label>
        <label>
          <span>Org</span>
          <select id="filterOrg"></select>
        </label>
        <label>
          <span>Reasoning</span>
          <select id="filterReasoning"></select>
        </label>
        <label>
          <span>Technique</span>
          <select id="filterTechnique"></select>
        </label>
        <label>
          <span>Domain</span>
          <select id="filterDomain"></select>
        </label>
      </div>
      <div class="judge-filter-row">
        <span class="small-note">Judges (tick to include):</span>
        <label class="judge-chip">
          <input type="checkbox" id="judge1Toggle" checked>
          <span id="judge1Label">Loading...</span>
        </label>
        <label class="judge-chip">
          <input type="checkbox" id="judge2Toggle" checked>
          <span id="judge2Label">Loading...</span>
        </label>
        <label class="judge-chip">
          <input type="checkbox" id="judge3Toggle" checked>
          <span id="judge3Label">Loading...</span>
        </label>
      </div>
      <div class="filter-meta-row">
        <span class="small-note">Outcome filter:</span>
        <div class="score-filter" id="scoreFilter"></div>
      </div>
      <details class="model-visibility-block">
        <summary>Model visibility and quick actions</summary>
        <div class="model-visibility-inner">
        <label>
          <span>Search models</span>
          <input id="filterModelToggleSearch" type="text" placeholder="Search model names...">
        </label>
        <div class="button-row">
          <button id="primaryModelsBtn" class="alt" type="button">Primary Models: Off</button>
          <button id="showAllModelsBtn" class="alt" type="button">Show All Models</button>
          <button id="hideAllModelsBtn" class="alt" type="button">Hide All Models</button>
          <button id="clearFiltersBtn" class="alt" type="button">Reset All Filters</button>
        </div>
        <div id="modelToggleGrid" class="model-toggle-grid"></div>
        <p id="modelToggleNote" class="small-note"></p>
        </div>
      </details>
      <p class="small-note" id="dataState"></p>
    </section>

    <section class="panel">
      <div class="chart-head">
        <h2>BullshitBench: Models Answering Nonsense Questions</h2>
        <div class="chart-legend" aria-label="Model detection legend">
          <span class="chart-legend-item"><span class="dot score2"></span>Clear Pushback</span>
          <span class="chart-legend-item"><span class="dot score1"></span>Partial Challenge</span>
          <span class="chart-legend-item"><span class="dot score0"></span>Accepted Nonsense</span>
        </div>
      </div>
      <div class="chart-subguide" id="mainChartOrgGuide"></div>
      <div class="bar-list" id="simpleModelBars"></div>
    </section>

    <section class="panel hidden-block" id="chartDrilldownPanel">
      <div class="drilldown-head">
        <div>
          <h2 id="chartDrilldownTitle">BullshitBench: Selected Segment</h2>
          <p class="small-note" id="chartDrilldownMeta"></p>
        </div>
        <button type="button" id="clearChartDrilldownBtn" class="alt">Clear Selection</button>
      </div>
      <div id="chartDrilldownBody" class="drilldown-list"></div>
    </section>

    <section class="panel">
      <h2>BullshitBench: How have models improved?</h2>
      <p class="small-note">Tracing performance improvements (clear pushback %) with model releases.</p>
      <div class="launch-controls">
        <label class="launch-toggle">
          <input type="checkbox" id="launchBestOnlyToggle" checked>
          <span>Best models from the same release</span>
        </label>
      </div>
      <svg id="launchScatterSvg" class="launch-plot-svg" viewBox="0 0 1200 420" role="img" aria-label="Green percentage timeline for Anthropic OpenAI and Google models"></svg>
      <p id="launchScatterMeta" class="small-note"></p>
    </section>

    <section class="panel">
      <h2>BullshitBench: Model Leaderboard</h2>
      <div class="org-key-wrap">
        <span class="small-note">Company colors:</span>
        <div class="org-key" id="orgColorKey"></div>
      </div>
      <div class="table-wrap">
        <table>
          <thead id="leaderboardHead">
            <tr>
              <th class="sortable-th" data-sort-key="rank">Rank <span class="sort-ind" data-sort-ind="rank"></span></th>
              <th class="sortable-th" data-sort-key="model">Model <span class="sort-ind" data-sort-ind="model"></span></th>
              <th class="sortable-th" data-sort-key="org">Org <span class="sort-ind" data-sort-ind="org"></span></th>
              <th class="sortable-th" data-sort-key="reasoning">Reasoning <span class="sort-ind" data-sort-ind="reasoning"></span></th>
              <th class="sortable-th" data-sort-key="launchDate">Launch Date <span class="sort-ind" data-sort-ind="launchDate"></span></th>
              <th class="sortable-th" data-sort-key="modelAgeDays">Model Age (days) <span class="sort-ind" data-sort-ind="modelAgeDays"></span></th>
              <th class="sortable-th" data-sort-key="greenRate">Green % <span class="sort-ind" data-sort-ind="greenRate"></span></th>
              <th class="sortable-th" data-sort-key="amberRate">Amber % <span class="sort-ind" data-sort-ind="amberRate"></span></th>
              <th class="sortable-th" data-sort-key="redRate">Red % <span class="sort-ind" data-sort-ind="redRate"></span></th>
              <th class="sortable-th" data-sort-key="errorRate">Error % <span class="sort-ind" data-sort-ind="errorRate"></span></th>
              <th>Mix (Green/Amber/Red/Error)</th>
              <th class="sortable-th" data-sort-key="rows">Rows <span class="sort-ind" data-sort-ind="rows"></span></th>
            </tr>
          </thead>
          <tbody id="leaderboardBody"></tbody>
        </table>
      </div>
    </section>

    <section class="panel">
      <h2>BullshitBench: Response Viewer</h2>
      <div class="compare-controls">
        <label>
          <span>Question</span>
          <select id="compareQuestion"></select>
        </label>
        <label>
          <span>Model A</span>
          <select id="compareModelA"></select>
        </label>
        <label>
          <span>Model B</span>
          <select id="compareModelB"></select>
        </label>
        <label>
          <span>View</span>
          <select id="compareViewMode">
            <option value="pair">Compare 2</option>
            <option value="all">Show all</option>
          </select>
        </label>
        <label>
          <span>Question % Correct</span>
          <select id="compareQuestionBand">
            <option value="all">All</option>
            <option value="80_100">80-100%</option>
            <option value="60_80">60-79%</option>
            <option value="40_60">40-59%</option>
            <option value="20_40">20-39%</option>
            <option value="0_20">0-19%</option>
          </select>
        </label>
      </div>
      <div class="button-row compare-actions">
        <button type="button" id="randomGreenRedBtn" class="btn-green-red-primary">Random</button>
        <button type="button" id="randomBestQuestionBtn" class="alt btn-best">Random Best Question</button>
        <button type="button" id="randomWorstQuestionBtn" class="alt btn-worst">Random Worst Question</button>
      </div>
      <div id="questionContext" class="question-context"></div>
      <div id="pairGrid" class="ab-grid">
        <div id="modelACard"></div>
        <div id="modelBCard"></div>
      </div>
      <div id="allResponsesGrid" class="ab-grid all-responses-grid hidden-block"></div>
    </section>
  </div>

  <script>
    const DEFAULT_PATHS = {
      responses: "data/latest/responses.jsonl",
      collectionStats: "data/latest/collection_stats.json",
      panelSummary: "data/latest/panel_summary.json",
      aggregateSummary: "data/latest/aggregate_summary.json",
      aggregateRows: "data/latest/aggregate.jsonl",
      launchMetadata: "data/latest/model_launch_dates.csv",
    };

    const CATEGORY_META = {
      green: { label: "Green", colorClass: "score2", short: "Green" },
      amber: { label: "Amber", colorClass: "score1", short: "Amber" },
      red: { label: "Red", colorClass: "score0", short: "Red" },
      error: { label: "Error", colorClass: "error", short: "Error" },
    };
    const CATEGORY_ORDER = ["green", "amber", "red", "error"];
    const ORG_COLOR_OVERRIDES = {
      anthropic: "#f97316",
      openai: "#111827",
      google: "#1a73e8",
      "x-ai": "#6d28d9",
      mistralai: "#ec4899",
      deepseek: "#06b6d4",
      bytedance: "#0ea5e9",
      "bytedance-seed": "#0ea5e9",
      xiaomi: "#ff6900",
      qwen: "#7c3aed",
      moonshotai: "#0284c7",
      minimax: "#14b8a6",
      baidu: "#1d4ed8",
      "prime-intellect": "#64748b",
      "z-ai": "#0f766e",
    };
    const ORG_NAME_OVERRIDES = {
      anthropic: "Anthropic",
      openai: "OpenAI",
      google: "Google",
      "x-ai": "xAI",
      xai: "xAI",
      mistralai: "Mistral",
      deepseek: "DeepSeek",
      bytedance: "ByteDance",
      "bytedance-seed": "ByteDance",
      xiaomi: "Xiaomi",
      qwen: "Qwen",
      moonshotai: "Moonshot AI",
      minimax: "MiniMax",
      baidu: "Baidu",
      "prime-intellect": "Prime Intellect",
      "z-ai": "Z.AI",
    };
    const TECHNIQUE_LABELS = {
      authoritative_framing_of_nothing: "Confident Nonsense Framing",
      causal_chimera: "Fake Cause-and-Effect Mix",
      cross_domain_concept_stitching: "Cross-Domain Concept Stitching",
      false_granularity: "Fake Precision",
      inverted_nonexistent_dependency: "Invented Dependency Reversal",
      misapplied_mechanism: "Misapplied Mechanism",
      plausible_nonexistent_framework: "Plausible but Fake Framework",
      reified_metaphor: "Literalized Metaphor",
      temporal_category_error: "Time/Category Mix-up",
      wrong_unit_of_analysis: "Wrong Unit of Analysis",
    };

    const state = {
      responses: [],
      collectionStats: null,
      panelSummary: null,
      aggregateSummary: null,
      aggregateRows: [],
      launchMetadataRows: [],
      launchByModel: new Map(),
      rows: [],
      filteredRows: [],
      bySampleId: new Map(),
      questionRows: [],
      lastCompareQuestionId: "",
      hiddenModels: new Set(),
      primaryOnly: false,
      primaryModelKeys: new Set(),
      selectedJudges: new Set([1, 2, 3]),
      chartDrilldown: null,
      leaderboardSort: {
        key: "greenRate",
        direction: "desc",
      },
      launchScatterWidth: 0,
    };

    const el = {};

    function cacheElements() {
      el.dataState = document.getElementById("dataState");
      el.simpleModelBars = document.getElementById("simpleModelBars");
      el.mainChartOrgGuide = document.getElementById("mainChartOrgGuide");
      el.leaderboardHead = document.getElementById("leaderboardHead");
      el.leaderboardBody = document.getElementById("leaderboardBody");
      el.launchScatterSvg = document.getElementById("launchScatterSvg");
      el.launchScatterMeta = document.getElementById("launchScatterMeta");
      el.launchBestOnlyToggle = document.getElementById("launchBestOnlyToggle");
      el.chartDrilldownPanel = document.getElementById("chartDrilldownPanel");
      el.chartDrilldownTitle = document.getElementById("chartDrilldownTitle");
      el.chartDrilldownMeta = document.getElementById("chartDrilldownMeta");
      el.chartDrilldownBody = document.getElementById("chartDrilldownBody");
      el.clearChartDrilldownBtn = document.getElementById("clearChartDrilldownBtn");
      el.scoreFilter = document.getElementById("scoreFilter");
      el.clearFiltersBtn = document.getElementById("clearFiltersBtn");
      el.filterOrg = document.getElementById("filterOrg");
      el.orgColorKey = document.getElementById("orgColorKey");
      el.filterModelToggleSearch = document.getElementById("filterModelToggleSearch");
      el.modelToggleGrid = document.getElementById("modelToggleGrid");
      el.modelToggleNote = document.getElementById("modelToggleNote");
      el.primaryModelsBtn = document.getElementById("primaryModelsBtn");
      el.showAllModelsBtn = document.getElementById("showAllModelsBtn");
      el.hideAllModelsBtn = document.getElementById("hideAllModelsBtn");
      el.filterReasoning = document.getElementById("filterReasoning");
      el.filterTechnique = document.getElementById("filterTechnique");
      el.filterDomain = document.getElementById("filterDomain");
      el.judge1Toggle = document.getElementById("judge1Toggle");
      el.judge2Toggle = document.getElementById("judge2Toggle");
      el.judge3Toggle = document.getElementById("judge3Toggle");
      el.judge1Label = document.getElementById("judge1Label");
      el.judge2Label = document.getElementById("judge2Label");
      el.judge3Label = document.getElementById("judge3Label");
      el.filterQuery = document.getElementById("filterQuery");
      el.compareQuestion = document.getElementById("compareQuestion");
      el.compareModelA = document.getElementById("compareModelA");
      el.compareModelB = document.getElementById("compareModelB");
      el.compareViewMode = document.getElementById("compareViewMode");
      el.compareQuestionBand = document.getElementById("compareQuestionBand");
      el.randomGreenRedBtn = document.getElementById("randomGreenRedBtn");
      el.randomBestQuestionBtn = document.getElementById("randomBestQuestionBtn");
      el.randomWorstQuestionBtn = document.getElementById("randomWorstQuestionBtn");
      el.questionContext = document.getElementById("questionContext");
      el.pairGrid = document.getElementById("pairGrid");
      el.allResponsesGrid = document.getElementById("allResponsesGrid");
      el.modelACard = document.getElementById("modelACard");
      el.modelBCard = document.getElementById("modelBCard");
    }

    function escapeHtml(value) {
      return String(value ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function normalizeOrg(value) {
      return String(value || "unknown").trim().toLowerCase();
    }

    function hashString(text) {
      const input = String(text || "");
      let hash = 0;
      for (let i = 0; i < input.length; i += 1) {
        hash = ((hash << 5) - hash + input.charCodeAt(i)) | 0;
      }
      return Math.abs(hash);
    }

    function modelOrg(row) {
      const explicit = String((row && row.model_org) || "").trim();
      if (explicit) {
        return explicit;
      }
      const rawModel = String((row && row.model) || "");
      const slash = rawModel.indexOf("/");
      if (slash > 0) {
        return rawModel.slice(0, slash);
      }
      return "unknown";
    }

    function displayOrg(orgValue) {
      const raw = String(orgValue || "").trim();
      if (!raw) {
        return "Unknown";
      }
      const normalized = normalizeOrg(raw);
      if (ORG_NAME_OVERRIDES[normalized]) {
        return ORG_NAME_OVERRIDES[normalized];
      }
      const tokenAlias = {
        ai: "AI",
      };
      return normalized
        .replace(/[^a-z0-9]+/g, " ")
        .trim()
        .split(/\s+/)
        .filter(Boolean)
        .map((token) => tokenAlias[token] || (token.charAt(0).toUpperCase() + token.slice(1)))
        .join(" ");
    }

    function orgColor(orgValue) {
      const normalized = normalizeOrg(orgValue);
      if (ORG_COLOR_OVERRIDES[normalized]) {
        return ORG_COLOR_OVERRIDES[normalized];
      }
      const hue = hashString(normalized) % 360;
      return `hsl(${hue} 60% 42%)`;
    }

    function renderOrgFilterChip(org, count) {
      const swatch = orgColor(org);
      const orgLabel = displayOrg(org);
      const selectedOrg = el.filterOrg && el.filterOrg.value
        ? String(el.filterOrg.value)
        : "all";
      const isActive = selectedOrg === org;
      const activeClass = isActive ? " is-active" : "";
      const mutedClass = selectedOrg !== "all" && !isActive ? " is-muted" : "";
      const title = isActive
        ? "Click to show all companies"
        : `Click to show only ${orgLabel}`;
      return `
        <button type="button" class="org-chip filter-chip${activeClass}${mutedClass}" data-org-toggle="${escapeHtml(org)}" title="${escapeHtml(title)}" aria-pressed="${isActive ? "true" : "false"}" aria-label="${escapeHtml(title)}">
          <span class="org-dot" style="background:${escapeHtml(swatch)};"></span>
          <span>${escapeHtml(orgLabel)}</span>
          <span class="org-count">${count}</span>
        </button>
      `;
    }

    function defaultPathPrefix() {
      const pathname = window.location.pathname || "";
      return pathname.includes("/viewer/") ? "../" : "";
    }

    function resolvedDefaultPaths() {
      const prefix = defaultPathPrefix();
      return {
        responses: `${prefix}${DEFAULT_PATHS.responses}`,
        collectionStats: `${prefix}${DEFAULT_PATHS.collectionStats}`,
        panelSummary: `${prefix}${DEFAULT_PATHS.panelSummary}`,
        aggregateSummary: `${prefix}${DEFAULT_PATHS.aggregateSummary}`,
        aggregateRows: `${prefix}${DEFAULT_PATHS.aggregateRows}`,
        launchMetadata: `${prefix}${DEFAULT_PATHS.launchMetadata}`,
      };
    }

    function setDataState(message) {
      if (el.dataState) {
        el.dataState.textContent = message;
      }
    }

    function parseJsonlStrict(text, filename) {
      const out = [];
      const lines = text.split(/\r?\n/);
      for (let i = 0; i < lines.length; i += 1) {
        const line = lines[i].trim();
        if (!line) {
          continue;
        }
        try {
          out.push(JSON.parse(line));
        } catch (error) {
          throw new Error(`${filename}: invalid JSONL at line ${i + 1}`);
        }
      }
      return out;
    }

    function parseJsonlTolerant(text, filename) {
      const out = [];
      let buffer = "";
      let depth = 0;
      let inString = false;
      let escaping = false;
      let lineNo = 1;
      let recordStartLine = 1;

      for (let i = 0; i < text.length; i += 1) {
        const ch = text[i];

        if (depth === 0) {
          if (!/\S/.test(ch)) {
            if (ch === "\n") {
              lineNo += 1;
            }
            continue;
          }
          if (ch !== "{") {
            throw new Error(`${filename}: invalid JSONL near line ${lineNo}`);
          }
          buffer = "{";
          depth = 1;
          inString = false;
          escaping = false;
          recordStartLine = lineNo;
          continue;
        }

        if (inString) {
          if (escaping) {
            buffer += ch;
            escaping = false;
          } else if (ch === "\\") {
            buffer += ch;
            escaping = true;
          } else if (ch === "\"") {
            buffer += ch;
            inString = false;
          } else if (ch === "\n") {
            buffer += "\\n";
            lineNo += 1;
            continue;
          } else if (ch === "\r") {
            buffer += "\\r";
          } else {
            buffer += ch;
          }
        } else {
          buffer += ch;
          if (ch === "\"") {
            inString = true;
          } else if (ch === "{") {
            depth += 1;
          } else if (ch === "}") {
            depth -= 1;
            if (depth === 0) {
              try {
                out.push(JSON.parse(buffer));
              } catch (_error) {
                throw new Error(`${filename}: invalid JSON object starting at line ${recordStartLine}`);
              }
              buffer = "";
            }
          }
        }

        if (ch === "\n") {
          lineNo += 1;
        }
      }

      if (depth !== 0 || inString) {
        throw new Error(`${filename}: unterminated JSON object near line ${recordStartLine}`);
      }

      return out;
    }

    function parseJsonl(text, filename) {
      try {
        return parseJsonlStrict(text, filename);
      } catch (strictError) {
        try {
          return parseJsonlTolerant(text, filename);
        } catch (_fallbackError) {
          throw strictError;
        }
      }
    }

    function parseCsvLine(line) {
      const out = [];
      let token = "";
      let inQuotes = false;
      for (let idx = 0; idx < line.length; idx += 1) {
        const ch = line[idx];
        if (inQuotes) {
          if (ch === "\"") {
            if (line[idx + 1] === "\"") {
              token += "\"";
              idx += 1;
            } else {
              inQuotes = false;
            }
          } else {
            token += ch;
          }
        } else if (ch === "\"") {
          inQuotes = true;
        } else if (ch === ",") {
          out.push(token);
          token = "";
        } else {
          token += ch;
        }
      }
      out.push(token);
      return out;
    }

    function parseCsv(text, filename) {
      const lines = String(text || "")
        .replace(/\r\n/g, "\n")
        .split("\n")
        .filter((line) => line.trim().length > 0);
      if (!lines.length) {
        return [];
      }
      const header = parseCsvLine(lines[0]).map((cell) => String(cell || "").trim());
      if (!header.length || header.some((key) => !key)) {
        throw new Error(`${filename}: invalid CSV header`);
      }
      return lines.slice(1).map((line) => {
        const cells = parseCsvLine(line);
        const row = {};
        header.forEach((key, idx) => {
          row[key] = cells[idx] !== undefined ? String(cells[idx]) : "";
        });
        return row;
      });
    }

    function fetchCandidates(path) {
      const input = String(path || "").trim();
      const candidates = [];
      const push = (candidate) => {
        if (candidate && !candidates.includes(candidate)) {
          candidates.push(candidate);
        }
      };

      if (!input) {
        return candidates;
      }

      if (/^https?:\/\//i.test(input)) {
        push(input);
        return candidates;
      }

      push(input);
      if (input.startsWith("./")) {
        push(input.slice(2));
      }
      if (!input.startsWith("/")) {
        push(`/${input}`);
      } else {
        push(input.slice(1));
      }
      if (!input.startsWith("../")) {
        push(`../${input}`);
      } else {
        push(input.replace(/^\.\.\//, ""));
      }
      return candidates;
    }

    function embeddedFileStore() {
      const store = window.__BULLSHIT_BENCHMARK_EMBEDDED_FILES__;
      return store && typeof store === "object" ? store : null;
    }

    function embeddedTextForPath(path) {
      const store = embeddedFileStore();
      if (!store) {
        return null;
      }

      const candidates = fetchCandidates(path);
      for (const candidate of candidates) {
        const raw = String(candidate || "").trim();
        if (!raw) {
          continue;
        }
        const noDotPrefix = raw.replace(/^\.\//, "");
        const noLeadingSlash = noDotPrefix.replace(/^\//, "");
        const noViewerPrefix = noLeadingSlash.replace(/^viewer\//, "");
        const keys = [
          raw,
          noDotPrefix,
          noLeadingSlash,
          noViewerPrefix,
          `viewer/${noViewerPrefix}`,
        ];
        for (const key of keys) {
          if (Object.prototype.hasOwnProperty.call(store, key)) {
            return String(store[key]);
          }
        }
      }
      return null;
    }

    async function fetchText(path) {
      const candidates = fetchCandidates(path);
      if (!candidates.length) {
        throw new Error("missing file path");
      }
      const embedded = embeddedTextForPath(path);
      if (embedded !== null) {
        return embedded;
      }
      let lastError = `${path} (unresolved)`;

      for (const candidate of candidates) {
        try {
          const response = await fetch(candidate, { cache: "no-store" });
          if (response.ok) {
            return response.text();
          }
          lastError = `${candidate} (${response.status})`;
        } catch (error) {
          lastError = `${candidate} (${error.message})`;
        }
      }
      throw new Error(lastError);
    }

    function titleCaseWord(token) {
      if (!token) {
        return "";
      }
      const lower = String(token).toLowerCase();
      const alias = {
        gpt: "GPT",
        oss: "OSS",
        ai: "AI",
        it: "IT",
        glm: "GLM",
      };
      if (alias[lower]) {
        return alias[lower];
      }
      if (/^\d+[a-z]+$/i.test(token)) {
        return lower;
      }
      if (/^[a-z]\d+$/i.test(token)) {
        return lower;
      }
      return token.charAt(0).toUpperCase() + token.slice(1);
    }

    function rawModelName(row) {
      if (row && row.model_name) {
        return String(row.model_name);
      }
      const model = String((row && row.model) || "");
      const slashIdx = model.indexOf("/");
      const tail = slashIdx >= 0 ? model.slice(slashIdx + 1) : model;
      const atIdx = tail.indexOf("@");
      return atIdx >= 0 ? tail.slice(0, atIdx) : tail;
    }

    function normalizeReasoningLevel(value) {
      const raw = String(value || "none").toLowerCase();
      return raw === "default" ? "none" : raw;
    }

    function reasoningFilterLevel(value) {
      const normalized = normalizeReasoningLevel(value);
      return normalized === "xhigh" ? "high" : normalized;
    }

    function prettyModelName(row) {
      const raw = rawModelName(row).replace(/_/g, "-");
      const tokens = raw.split("-").filter(Boolean);
      if (!tokens.length) {
        return "Model";
      }
      const mapped = tokens.map((token) => titleCaseWord(token));
      if (mapped[0] === "GPT" && tokens[1] && /^\d/.test(tokens[1])) {
        mapped.splice(0, 2, `GPT-${tokens[1]}`);
      }
      const reasoning = normalizeReasoningLevel(row && row.model_reasoning_level);
      const suffix = reasoning && reasoning !== "none"
        ? ` (${reasoning.charAt(0).toUpperCase()}${reasoning.slice(1)})`
        : "";
      return `${mapped.join(" ")}${suffix}`;
    }

    function modelKey(row) {
      if (!row) {
        return "";
      }
      if (row.model) {
        return String(row.model);
      }
      const org = String(row.model_org || "unknown");
      const name = String(rawModelName(row) || "model");
      const reasoning = String(row.model_reasoning_level || "none");
      return `${org}/${name}@reasoning=${reasoning}`;
    }

    function baseModelIdFromRow(row) {
      if (!row) {
        return "";
      }
      const modelId = String((row && row.model_id) || "").trim();
      if (modelId) {
        return modelId.replace(/@reasoning=[^@]+$/i, "");
      }
      const key = modelKey(row);
      return String(key || "").replace(/@reasoning=[^@]+$/i, "");
    }

    function parseIsoDate(value) {
      const text = String(value || "").trim();
      if (!/^\d{4}-\d{2}-\d{2}$/.test(text)) {
        return null;
      }
      const date = new Date(`${text}T00:00:00Z`);
      if (Number.isNaN(date.getTime())) {
        return null;
      }
      return date;
    }

    function launchMetadataForRow(row) {
      const modelBase = baseModelIdFromRow(row);
      if (!modelBase) {
        return null;
      }
      return state.launchByModel.get(modelBase) || null;
    }

    function modelAgeDaysForRow(row) {
      const launch = launchMetadataForRow(row);
      if (!launch) {
        return null;
      }
      const launchDate = parseIsoDate(launch.launch_date);
      if (!launchDate) {
        return null;
      }
      const now = new Date();
      const utcToday = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
      const diffMs = utcToday.getTime() - launchDate.getTime();
      if (diffMs < 0) {
        return null;
      }
      return Math.floor(diffMs / 86400000);
    }

    function baseModelGroupKey(row) {
      const org = String((row && row.model_org) || "unknown");
      const name = rawModelName(row) || "model";
      return `${org}/${name}`;
    }

    function reasoningPreference(level) {
      const normalized = normalizeReasoningLevel(level);
      if (normalized === "none") {
        return 3;
      }
      if (normalized === "high") {
        return 2;
      }
      if (normalized === "low") {
        return 1;
      }
      return 0;
    }

    function judgeScoreFromRow(row, judgeIndex) {
      if (!row) {
        return null;
      }
      const statusKey = `judge_${judgeIndex}_status`;
      const scoreKeyName = `judge_${judgeIndex}_score`;
      const status = String(row[statusKey] || "");
      if (status && status !== "ok") {
        return null;
      }
      const score = Number(row[scoreKeyName]);
      if (Number.isNaN(score) || ![0, 1, 2, 3].includes(score)) {
        return null;
      }
      return score;
    }

    function selectedJudgeIds() {
      return [...state.selectedJudges].sort((a, b) => a - b);
    }

    function syncSelectedJudgesFromUI(changedJudge = null) {
      const selected = new Set();
      if (el.judge1Toggle.checked && !el.judge1Toggle.disabled) {
        selected.add(1);
      }
      if (el.judge2Toggle.checked && !el.judge2Toggle.disabled) {
        selected.add(2);
      }
      if (el.judge3Toggle.checked && !el.judge3Toggle.disabled) {
        selected.add(3);
      }

      if (!selected.size) {
        const fallback = changedJudge && !el[`judge${changedJudge}Toggle`].disabled
          ? changedJudge
          : [1, 2, 3].find((judgeIndex) => {
            const toggle = el[`judge${judgeIndex}Toggle`];
            return toggle && !toggle.disabled;
          });
        if (fallback) {
          el[`judge${fallback}Toggle`].checked = true;
          selected.add(fallback);
        }
      }
      state.selectedJudges = selected;
    }

    function judgeModelName(judgeIndex) {
      const field = `judge_${judgeIndex}_model`;
      for (const row of state.rows) {
        const value = row && row[field];
        if (value) {
          return String(value);
        }
      }
      return "";
    }

    function refreshJudgeFilterLabels() {
      [1, 2, 3].forEach((judgeIndex) => {
        const toggle = el[`judge${judgeIndex}Toggle`];
        const label = el[`judge${judgeIndex}Label`];
        if (!toggle || !label) {
          return;
        }
        const model = judgeModelName(judgeIndex);
        if (model) {
          label.textContent = displayModel({ model });
          toggle.disabled = false;
        } else {
          label.textContent = "Unavailable";
          toggle.checked = false;
          toggle.disabled = true;
        }
      });
      syncSelectedJudgesFromUI();
    }

    function categoryFromScore(score) {
      if (score === 2 || score === "2") {
        return "green";
      }
      if (score === 1 || score === "1") {
        return "amber";
      }
      if (score === 0 || score === "0" || score === 3 || score === "3") {
        return "red";
      }
      return "error";
    }

    function categoryKey(row) {
      const chosenJudges = selectedJudgeIds();
      if (!chosenJudges.length) {
        return "error";
      }
      const categories = chosenJudges
        .map((judgeIndex) => judgeScoreFromRow(row, judgeIndex))
        .filter((score) => score !== null)
        .map((score) => categoryFromScore(score));

      if (!categories.length) {
        return "error";
      }
      if (categories.length === 1) {
        return categories[0];
      }

      const counts = { green: 0, amber: 0, red: 0 };
      categories.forEach((category) => {
        if (Object.prototype.hasOwnProperty.call(counts, category)) {
          counts[category] += 1;
        }
      });
      const maxCount = Math.max(counts.green, counts.amber, counts.red);
      const winners = Object.entries(counts)
        .filter(([, count]) => count === maxCount && count > 0)
        .map(([category]) => category);

      if (winners.length === 1) {
        return winners[0];
      }
      return "amber";
    }

    function categoryRank(category) {
      if (category === "green") {
        return 3;
      }
      if (category === "amber") {
        return 2;
      }
      if (category === "red") {
        return 1;
      }
      return 0;
    }

    function displayModel(row) {
      if (!row) {
        return "N/A";
      }
      return prettyModelName(row);
    }

    function launchChartModelLabel(text) {
      return String(text || "")
        .replace(/:thinking\b/ig, "")
        .replace(/\bpreview\b/ig, "")
        .replace(/\s*\((?:x?high|low)\)/ig, "")
        .replace(/\bflash\s+0*01\b/ig, "Flash")
        .replace(/\b20\d{2}[ _-]\d{2}[ _-]\d{2}\b/g, "")
        .replace(/\s{2,}/g, " ")
        .replace(/\s+\)/g, ")")
        .trim();
    }

    function normalizeRows(aggregateRows, responses) {
      if (!aggregateRows.length) {
        return responses.map((row) => ({
          ...row,
          consensus_score: null,
          status: row.status || "ok",
          judge_1_score: null,
          judge_2_score: null,
          judge_3_score: null,
          judge_1_justification: "",
          judge_2_justification: "",
          judge_3_justification: "",
        }));
      }

      const responseMap = new Map();
      responses.forEach((r) => {
        if (r.sample_id) {
          responseMap.set(r.sample_id, r);
        }
      });

      return aggregateRows.map((row) => {
        const source = responseMap.get(row.sample_id) || {};
        return {
          ...source,
          ...row,
          response_text: row.response_text || source.response_text || "",
          question: row.question || source.question || "",
          nonsensical_element: row.nonsensical_element || source.nonsensical_element || "",
        };
      });
    }

    function uniqSorted(values) {
      return [...new Set(values.filter((v) => v !== undefined && v !== null && String(v).length > 0))]
        .map(String)
        .sort((a, b) => a.localeCompare(b));
    }

    function displayTechnique(value) {
      const raw = String(value || "unknown");
      if (TECHNIQUE_LABELS[raw]) {
        return TECHNIQUE_LABELS[raw];
      }
      return raw
        .split("_")
        .filter(Boolean)
        .map((token) => titleCaseWord(token))
        .join(" ");
    }

    function fillSelect(selectEl, values, keep = "all", labelFormatter = (value) => value) {
      const previous = selectEl.value;
      const options = [`<option value="all">All</option>`];
      values.forEach((value) => {
        options.push(
          `<option value="${escapeHtml(value)}">${escapeHtml(labelFormatter(value))}</option>`,
        );
      });
      selectEl.innerHTML = options.join("");
      if (previous && values.includes(previous)) {
        selectEl.value = previous;
      } else {
        selectEl.value = keep;
      }
    }

    function collectModelInfos(rows) {
      const map = new Map();
      rows.forEach((row) => {
        const key = modelKey(row);
        if (!key || map.has(key)) {
          return;
        }
        map.set(key, { key, label: displayModel(row) });
      });
      return [...map.values()].sort((a, b) => a.label.localeCompare(b.label));
    }

    function computePrimaryModelKeys(rows) {
      const NON_REASONING_MIN_COVERAGE_RATIO = 0.85;
      const NON_REASONING_MAX_GREEN_GAP = 0.03;
      const groups = new Map();
      rows.forEach((row) => {
        const groupKey = baseModelGroupKey(row);
        const variantKey = modelKey(row);
        if (!groups.has(groupKey)) {
          groups.set(groupKey, new Map());
        }
        const variants = groups.get(groupKey);
        if (!variants.has(variantKey)) {
          variants.set(variantKey, {
            key: variantKey,
            scoredRows: 0,
            totalRows: 0,
            reasoningPref: reasoningPreference(row.model_reasoning_level),
            isNonReasoning: normalizeReasoningLevel(row.model_reasoning_level) === "none",
            greenRows: 0,
            redRows: 0,
          });
        }
        const variant = variants.get(variantKey);
        variant.totalRows += 1;
        const category = categoryKey(row);
        if (category === "green") {
          variant.greenRows += 1;
        } else if (category === "red") {
          variant.redRows += 1;
        }
        if (category !== "error") {
          variant.scoredRows += 1;
        }
      });

      const winners = new Set();
      groups.forEach((variants) => {
        const list = [...variants.values()];
        list.forEach((variant) => {
          const denom = variant.scoredRows || 1;
          variant.greenRate = variant.greenRows / denom;
          variant.redRate = variant.redRows / denom;
        });

        const bestCoverage = list.reduce((maxValue, variant) => Math.max(maxValue, variant.scoredRows), 0);
        const bestGreenRate = list.reduce((maxValue, variant) => Math.max(maxValue, variant.greenRate), 0);

        let preferredNonReasoning = null;
        const nonReasoningVariants = list
          .filter((variant) => variant.isNonReasoning)
          .sort((a, b) => {
            if (b.scoredRows !== a.scoredRows) {
              return b.scoredRows - a.scoredRows;
            }
            if (b.greenRate !== a.greenRate) {
              return b.greenRate - a.greenRate;
            }
            if (a.redRate !== b.redRate) {
              return a.redRate - b.redRate;
            }
            if (b.totalRows !== a.totalRows) {
              return b.totalRows - a.totalRows;
            }
            return a.key.localeCompare(b.key);
          });

        if (nonReasoningVariants[0]) {
          const candidate = nonReasoningVariants[0];
          const coverageRatio = bestCoverage === 0 ? 1 : candidate.scoredRows / bestCoverage;
          const greenGap = bestGreenRate - candidate.greenRate;
          if (coverageRatio >= NON_REASONING_MIN_COVERAGE_RATIO && greenGap <= NON_REASONING_MAX_GREEN_GAP) {
            preferredNonReasoning = candidate;
          }
        }

        if (preferredNonReasoning) {
          winners.add(preferredNonReasoning.key);
          return;
        }

        list.sort((a, b) => {
          if (b.scoredRows !== a.scoredRows) {
            return b.scoredRows - a.scoredRows;
          }
          if (b.greenRate !== a.greenRate) {
            return b.greenRate - a.greenRate;
          }
          if (a.redRate !== b.redRate) {
            return a.redRate - b.redRate;
          }
          if (b.totalRows !== a.totalRows) {
            return b.totalRows - a.totalRows;
          }
          if (b.reasoningPref !== a.reasoningPref) {
            return b.reasoningPref - a.reasoningPref;
          }
          return a.key.localeCompare(b.key);
        });
        if (list[0]) {
          winners.add(list[0].key);
        }
      });
      return winners;
    }

    function updatePrimaryModelsButton() {
      const active = state.primaryOnly;
      const count = state.primaryModelKeys.size;
      el.primaryModelsBtn.textContent = active
        ? `Primary Models: On (${count})`
        : "Primary Models: Off";
      el.primaryModelsBtn.classList.toggle("active", active);
    }

    function renderModelToggleGrid(modelInfos) {
      const query = (el.filterModelToggleSearch.value || "").trim().toLowerCase();
      const knownKeys = new Set(modelInfos.map((info) => info.key));
      state.hiddenModels = new Set(
        [...state.hiddenModels].filter((key) => knownKeys.has(key)),
      );

      const visibleInfos = modelInfos.filter((info) => {
        if (!query) {
          return true;
        }
        return info.label.toLowerCase().includes(query);
      });

      el.modelToggleGrid.innerHTML = visibleInfos
        .map((info) => {
          const isHidden = state.hiddenModels.has(info.key);
          const checked = isHidden ? "" : " checked";
          return `
            <label class="model-toggle-item ${isHidden ? "hidden" : ""}" title="${escapeHtml(isHidden ? "Unchecked (hidden)" : "Checked (shown)")}">
              <input type="checkbox" data-model-key="${escapeHtml(info.key)}"${checked}>
              <span>${escapeHtml(info.label)}</span>
            </label>
          `;
        })
        .join("");

      const hiddenCount = state.hiddenModels.size;
      const totalCount = modelInfos.length;
      const filteredCount = visibleInfos.length;
      const primaryInfo = state.primaryOnly
        ? `Primary set ON (${state.primaryModelKeys.size} models). `
        : `Primary set OFF. `;
      el.modelToggleNote.textContent = `${primaryInfo}Hidden: ${hiddenCount} of ${totalCount}. Showing ${filteredCount} in this list.`;
      updatePrimaryModelsButton();
    }

    function getCategorySelections() {
      const checks = [...document.querySelectorAll('input[name="scoreFilter"]:checked')];
      return new Set(checks.map((node) => node.value));
    }

    function buildScoreFilter() {
      el.scoreFilter.innerHTML = "";
      CATEGORY_ORDER.forEach((key) => {
        const meta = CATEGORY_META[key];
        const label = document.createElement("label");
        label.className = "score-chip";
        label.innerHTML = `
          <span class="dot ${meta.colorClass}"></span>
          <input type="checkbox" name="scoreFilter" value="${key}" checked>
          ${escapeHtml(meta.label)}
        `;
        const input = label.querySelector("input");
        input.addEventListener("change", renderAll);
        el.scoreFilter.appendChild(label);
      });
    }

    function orgModelCounts(rows) {
      const byOrg = new Map();
      rows.forEach((row) => {
        const org = modelOrg(row);
        const key = modelKey(row);
        if (!byOrg.has(org)) {
          byOrg.set(org, new Set());
        }
        byOrg.get(org).add(key);
      });
      return [...byOrg.entries()].map(([org, modelKeys]) => [org, modelKeys.size]);
    }

    function renderOrgColorKey(scopedRows) {
      if (!el.orgColorKey) {
        return;
      }
      const entries = orgModelCounts(scopedRows).sort((a, b) => {
        if (b[1] !== a[1]) {
          return b[1] - a[1];
        }
        return a[0].localeCompare(b[0]);
      });
      if (!entries.length) {
        el.orgColorKey.innerHTML = "";
        return;
      }
      el.orgColorKey.innerHTML = entries
        .map(([org, count]) => renderOrgFilterChip(org, count))
        .join("");
    }

    function applyFilters(rows, options = {}) {
      const org = el.filterOrg.value;
      const reasoning = el.filterReasoning.value;
      const technique = el.filterTechnique.value;
      const domain = el.filterDomain.value;
      const query = el.filterQuery.value.trim().toLowerCase();
      const allowedCategories = getCategorySelections();
      const excludedModelKeys = state.hiddenModels;
      const ignoreOrgFilter = Boolean(options.ignoreOrgFilter);

      return rows.filter((row) => {
        const rowOrg = modelOrg(row);
        const key = modelKey(row);
        if (!ignoreOrgFilter && org !== "all" && rowOrg !== org) {
          return false;
        }
        if (excludedModelKeys.has(key)) {
          return false;
        }
        if (state.primaryOnly && !state.primaryModelKeys.has(key)) {
          return false;
        }
        if (reasoning !== "all" && reasoningFilterLevel(row.model_reasoning_level) !== reasoning) {
          return false;
        }
        if (technique !== "all" && String(row.technique || "") !== technique) {
          return false;
        }
        if (domain !== "all" && String(row.domain || "") !== domain) {
          return false;
        }
        if (!allowedCategories.has(categoryKey(row))) {
          return false;
        }
        if (query) {
          const haystack = [
            displayModel(row),
            row.model || "",
            row.question_id,
            row.question,
            row.technique,
            row.domain,
            row.response_text,
          ]
            .join(" ")
            .toLowerCase();
          if (!haystack.includes(query)) {
            return false;
          }
        }
        return true;
      });
    }

    function pct(value, total) {
      if (!total) {
        return 0;
      }
      return (value / total) * 100;
    }

    function formatPct(value) {
      return `${Number(value).toFixed(1)}%`;
    }

    function aggregateCounts(rows) {
      const counts = { green: 0, amber: 0, red: 0, error: 0 };
      rows.forEach((row) => {
        counts[categoryKey(row)] += 1;
      });
      return counts;
    }

    function renderKpis(filteredRows) {
      const counts = aggregateCounts(filteredRows);
      const total = filteredRows.length;
      const scored = counts.green + counts.amber + counts.red;
      const greenRate = pct(counts.green, scored);
      const amberRate = pct(counts.amber, scored);
      const redRate = pct(counts.red, scored);

      const cards = [
        {
          label: "Visible Rows",
          value: total.toLocaleString(),
          hint: `${scored.toLocaleString()} categorized rows`,
          className: "",
        },
        {
          label: "Green Category",
          value: formatPct(greenRate),
          hint: `${counts.green} rows`,
          className: "green",
        },
        {
          label: "Amber Category",
          value: formatPct(amberRate),
          hint: `${counts.amber} rows`,
          className: "amber",
        },
        {
          label: "Red Category",
          value: formatPct(redRate),
          hint: `${counts.red} rows`,
          className: "red",
        },
        {
          label: "Errors",
          value: counts.error.toLocaleString(),
          hint: "Rows with no usable verdict",
          className: "error",
        },
      ];

      el.kpis.innerHTML = cards
        .map((card) => {
          return `
            <div class="kpi ${card.className}">
              <div class="label">${escapeHtml(card.label)}</div>
              <div class="value">${escapeHtml(card.value)}</div>
              <div class="hint">${escapeHtml(card.hint)}</div>
            </div>
          `;
        })
        .join("");
    }

    function renderScoreMix(filteredRows) {
      const counts = aggregateCounts(filteredRows);
      const total = filteredRows.length || 1;

      const segments = CATEGORY_ORDER
        .map((key) => {
          const width = pct(counts[key], total);
          return `<div class="mix-seg ${CATEGORY_META[key].colorClass}" style="width:${width}%;"></div>`;
        })
        .join("");
      el.scoreMixTrack.innerHTML = segments;

      const labels = CATEGORY_ORDER
        .map((key) => {
          const value = counts[key];
          const percent = pct(value, total);
          return `
            <span class="score-chip">
              <span class="dot ${CATEGORY_META[key].colorClass}"></span>
              ${escapeHtml(CATEGORY_META[key].label)}: ${percent.toFixed(1)}%
            </span>
          `;
        })
        .join("");
      el.scoreMixLabels.innerHTML = labels;
    }

    function groupBy(rows, keyFn) {
      const map = new Map();
      rows.forEach((row) => {
        const key = keyFn(row);
        if (!map.has(key)) {
          map.set(key, []);
        }
        map.get(key).push(row);
      });
      return map;
    }

    function summarizeRows(rows) {
      const counts = aggregateCounts(rows);
      const scored = counts.green + counts.amber + counts.red;
      return {
        counts,
        rows: rows.length,
        scored,
        greenRate: pct(counts.green, scored),
        amberRate: pct(counts.amber, scored),
        redRate: pct(counts.red, scored),
        errorRate: pct(counts.error, rows.length),
      };
    }

    function renderTechniqueBars(filteredRows) {
      const grouped = groupBy(filteredRows, (row) => String(row.technique || "unknown"));
      const data = [...grouped.entries()].map(([technique, rows]) => {
        const stats = summarizeRows(rows);
        return { technique, ...stats };
      });
      data.sort((a, b) => b.greenRate - a.greenRate || a.technique.localeCompare(b.technique));

      el.techniqueBars.innerHTML = data
        .map((item) => {
          return `
            <div class="bar-row">
              <div class="name">${escapeHtml(item.technique)}</div>
              <div class="bar"><span style="width:${item.greenRate.toFixed(2)}%"></span></div>
              <div class="bar-value">${formatPct(item.greenRate)}</div>
            </div>
          `;
        })
        .join("");
    }

    function renderMainChartOrgGuide(scopedRows) {
      if (!el.mainChartOrgGuide) {
        return;
      }
      const entries = orgModelCounts(scopedRows).sort((a, b) => (b[1] - a[1]) || a[0].localeCompare(b[0]));
      el.mainChartOrgGuide.innerHTML = entries.length
        ? `${entries.map(([org, count]) => renderOrgFilterChip(org, count)).join("")}`
        : "";
    }

    function renderSimpleModelBars(filteredRows) {
      const segmentLabel = (pct) => {
        if (pct >= 10) {
          return `${pct.toFixed(1)}%`;
        }
        if (pct >= 3) {
          return `${Math.round(pct)}%`;
        }
        return "";
      };

      const byModel = groupBy(filteredRows, (row) => modelKey(row));
      const rows = [...byModel.entries()].map(([key, modelRows]) => {
        const stats = summarizeRows(modelRows);
        const sample = modelRows[0] || {};
        const greenPct = stats.greenRate;
        const amberPct = stats.amberRate;
        const redPct = stats.redRate;
        return {
          key,
          label: displayModel(sample),
          org: modelOrg(sample),
          rows: modelRows.length,
          detectRate: greenPct,
          scored: stats.scored,
          greenPct,
          amberPct,
          redPct,
        };
      });

      rows.sort((a, b) => b.detectRate - a.detectRate || a.label.localeCompare(b.label));

      el.simpleModelBars.innerHTML = rows
        .map((row, idx) => {
          const rank = idx + 1;
          const selectedCategory = state.chartDrilldown && state.chartDrilldown.modelKey === row.key
            ? state.chartDrilldown.category
            : "";
          const greenSelected = selectedCategory === "green" ? " selected" : "";
          const amberSelected = selectedCategory === "amber" ? " selected" : "";
          const redSelected = selectedCategory === "red" ? " selected" : "";
          const orgSwatch = orgColor(row.org);
          return `
            <div class="stack-row">
              <div class="stack-rank">${rank}</div>
              <div class="name main-chart-name">
                <span class="org-dot" style="background:${escapeHtml(orgSwatch)};"></span>
                <span>${escapeHtml(row.label)}</span>
              </div>
              <div class="stack-track">
                <span class="stack-seg green${greenSelected}" data-model-key="${escapeHtml(row.key)}" data-category="green" style="width:${row.greenPct.toFixed(3)}%;" title="${escapeHtml(`Click to view ${row.label} Â· Green (${row.greenPct.toFixed(1)}%)`)}"><span class="seg-label">${escapeHtml(segmentLabel(row.greenPct))}</span></span>
                <span class="stack-seg amber${amberSelected}" data-model-key="${escapeHtml(row.key)}" data-category="amber" style="width:${row.amberPct.toFixed(3)}%;" title="${escapeHtml(`Click to view ${row.label} Â· Amber (${row.amberPct.toFixed(1)}%)`)}"><span class="seg-label">${escapeHtml(segmentLabel(row.amberPct))}</span></span>
                <span class="stack-seg red${redSelected}" data-model-key="${escapeHtml(row.key)}" data-category="red" style="width:${row.redPct.toFixed(3)}%;" title="${escapeHtml(`Click to view ${row.label} Â· Red (${row.redPct.toFixed(1)}%)`)}"><span class="seg-label">${escapeHtml(segmentLabel(row.redPct))}</span></span>
              </div>
            </div>
          `;
        })
        .join("");
    }

    function renderLaunchScatter(rows) {
      if (!el.launchScatterSvg || !el.launchScatterMeta) {
        return;
      }

      const RELEASE_WINDOW_DAYS = 3;
      const RELEASE_WINDOW_MS = RELEASE_WINDOW_DAYS * 86400000;
      const targetOrgs = new Set(["anthropic", "openai", "google"]);
      const byModel = groupBy(rows, (row) => modelKey(row));
      const rawPoints = [...byModel.entries()]
        .map(([, modelRows]) => {
          const sample = modelRows[0] || {};
          const org = normalizeOrg(modelOrg(sample));
          if (!targetOrgs.has(org)) {
            return null;
          }
          const launch = launchMetadataForRow(sample);
          if (!launch) {
            return null;
          }
          const launchDate = parseIsoDate(launch.launch_date);
          if (!launchDate) {
            return null;
          }
          const stats = summarizeRows(modelRows);
          const modelLabel = displayModel(sample);
          return {
            label: modelLabel,
            chartLabel: launchChartModelLabel(modelLabel),
            org,
            modelBase: baseModelIdFromRow(sample),
            launchDate,
            launchDateText: String(launch.launch_date || "").trim(),
            evidenceUrl: String(launch.evidence_url || "").trim(),
            greenRate: stats.greenRate,
          };
        })
        .filter(Boolean);

      if (!rawPoints.length) {
        el.launchScatterSvg.innerHTML = `<text x="50%" y="52%" text-anchor="middle" fill="#5d726b" font-size="16">No launch-mapped rows found for Anthropic, OpenAI, or Google.</text>`;
        el.launchScatterMeta.textContent = "Check data/latest/model_launch_dates.csv coverage.";
        return;
      }

      const bestOnly = !el.launchBestOnlyToggle || el.launchBestOnlyToggle.checked;
      const pickBestPoint = (windowPoints) => windowPoints
        .slice()
        .sort((a, b) => (
          b.greenRate - a.greenRate
          || b.launchDate.getTime() - a.launchDate.getTime()
          || a.label.localeCompare(b.label)
        ))[0];

      const points = bestOnly
        ? (() => {
            const kept = [];
            const pointsByOrg = new Map();
            rawPoints.forEach((point) => {
              if (!pointsByOrg.has(point.org)) {
                pointsByOrg.set(point.org, []);
              }
              pointsByOrg.get(point.org).push(point);
            });
            pointsByOrg.forEach((orgPoints) => {
              const sorted = orgPoints
                .slice()
                .sort((a, b) => a.launchDate.getTime() - b.launchDate.getTime() || a.label.localeCompare(b.label));
              let bucket = [];
              let bucketStart = null;
              sorted.forEach((point) => {
                const pointTime = point.launchDate.getTime();
                if (bucketStart === null || pointTime - bucketStart <= RELEASE_WINDOW_MS) {
                  if (bucketStart === null) {
                    bucketStart = pointTime;
                  }
                  bucket.push(point);
                  return;
                }
                kept.push(pickBestPoint(bucket));
                bucket = [point];
                bucketStart = pointTime;
              });
              if (bucket.length) {
                kept.push(pickBestPoint(bucket));
              }
            });
            return kept;
          })()
        : rawPoints.slice();

      if (!points.length) {
        el.launchScatterSvg.innerHTML = `<text x="50%" y="52%" text-anchor="middle" fill="#5d726b" font-size="16">No rows left after release-window selection.</text>`;
        el.launchScatterMeta.textContent = "Try disabling the release-window toggle.";
        return;
      }

      const byOrg = new Map();
      points.forEach((point) => {
        if (!byOrg.has(point.org)) {
          byOrg.set(point.org, []);
        }
        byOrg.get(point.org).push(point);
      });
      byOrg.forEach((orgPoints) => {
        orgPoints.sort((a, b) => a.launchDate.getTime() - b.launchDate.getTime() || a.label.localeCompare(b.label));
      });

      const measuredWidth = Math.round(el.launchScatterSvg.getBoundingClientRect().width || 0);
      const chartPixelWidth = Math.max(320, measuredWidth || state.launchScatterWidth || 1200);
      state.launchScatterWidth = chartPixelWidth;
      const width = chartPixelWidth;
      const viewportHeight = Math.max(420, Math.round((window.innerHeight || 900) * 0.62));
      const preferredHeight = Math.round(chartPixelWidth * 0.46);
      const baseMinHeight = chartPixelWidth <= 420 ? 360 : chartPixelWidth <= 560 ? 380 : 400;
      const height = Math.max(320, Math.min(viewportHeight, Math.max(baseMinHeight, preferredHeight)));
      const margin = chartPixelWidth <= 420
        ? { top: 18, right: 58, bottom: 70, left: 66 }
        : chartPixelWidth <= 560
          ? { top: 20, right: 68, bottom: 66, left: 74 }
          : { top: 22, right: 82, bottom: 62, left: 82 };
      const plotWidth = width - margin.left - margin.right;
      const plotHeight = height - margin.top - margin.bottom;
      const tickFontSize = chartPixelWidth <= 420 ? 11.2 : 12.8;
      const axisFontSize = chartPixelWidth <= 420 ? 12.8 : 14;
      el.launchScatterSvg.setAttribute("viewBox", `0 0 ${width} ${height}`);

      const dates = rawPoints.map((point) => point.launchDate.getTime());
      const minDateRaw = Math.min(...dates);
      const maxDateRaw = Math.max(...dates);
      const quarterStartUtc = (timeMs) => {
        const date = new Date(timeMs);
        const year = date.getUTCFullYear();
        const month = Math.floor(date.getUTCMonth() / 3) * 3;
        return Date.UTC(year, month, 1);
      };
      const addQuarterUtc = (timeMs, quarterCount = 1) => {
        const date = new Date(timeMs);
        return Date.UTC(date.getUTCFullYear(), date.getUTCMonth() + (quarterCount * 3), 1);
      };
      const quarterLabel = (timeMs) => {
        const date = new Date(timeMs);
        const quarter = Math.floor(date.getUTCMonth() / 3) + 1;
        return `Q${quarter} ${date.getUTCFullYear()}`;
      };
      const minDate = quarterStartUtc(minDateRaw);
      const maxDate = addQuarterUtc(quarterStartUtc(maxDateRaw), 1);
      const span = Math.max(1, maxDate - minDate);
      const xFor = (timeMs) => margin.left + ((timeMs - minDate) / span) * plotWidth;
      const yFor = (pctValue) => margin.top + ((100 - pctValue) / 100) * plotHeight;
      const isoDay = (timeMs) => new Date(timeMs).toISOString().slice(0, 10);

      const yTicks = [0, 20, 40, 60, 80, 100];
      let xTicks = [];
      for (let tick = minDate; tick <= maxDate; tick = addQuarterUtc(tick, 1)) {
        xTicks.push(tick);
        if (xTicks.length > 32) {
          break;
        }
      }
      if (!xTicks.length) {
        xTicks = [minDate, maxDate];
      }
      const maxXTicks = chartPixelWidth <= 420 ? 4
        : chartPixelWidth <= 560 ? 5
          : chartPixelWidth <= 760 ? 6
            : 9;
      if (xTicks.length > maxXTicks) {
        const step = Math.ceil(xTicks.length / maxXTicks);
        xTicks = xTicks.filter((_value, idx) => idx % step === 0 || idx === xTicks.length - 1);
      }

      const gridY = yTicks
        .map((tick) => {
          const y = yFor(tick);
          return `
            <line x1="${margin.left}" y1="${y.toFixed(2)}" x2="${width - margin.right}" y2="${y.toFixed(2)}" stroke="#d8e2dd" stroke-width="1" />
            <text x="${(margin.left - 10).toFixed(2)}" y="${(y + 4).toFixed(2)}" text-anchor="end" fill="#586d66" font-size="${tickFontSize.toFixed(1)}">${tick}%</text>
          `;
        })
        .join("");

      const gridX = xTicks
        .map((tick, idx) => {
          const x = xFor(tick);
          const isFirst = idx === 0;
          const isLast = idx === xTicks.length - 1;
          const anchor = isFirst ? "start" : isLast ? "end" : "middle";
          const labelX = isFirst ? x + 2 : isLast ? x - 2 : x;
          return `
            <line x1="${x.toFixed(2)}" y1="${margin.top}" x2="${x.toFixed(2)}" y2="${(height - margin.bottom).toFixed(2)}" stroke="#edf2ef" stroke-width="1" />
            <text x="${labelX.toFixed(2)}" y="${(height - margin.bottom + 18).toFixed(2)}" text-anchor="${anchor}" fill="#586d66" font-size="${tickFontSize.toFixed(1)}">${escapeHtml(quarterLabel(tick))}</text>
          `;
        })
        .join("");

      const mainLineData = [...byOrg.entries()]
        .sort((a, b) => a[0].localeCompare(b[0]))
        .map(([org, orgPoints]) => {
          const color = orgColor(org);
          const plotPoints = orgPoints.map((point) => ({
            x: xFor(point.launchDate.getTime()),
            y: yFor(point.greenRate),
          }));
          const path = plotPoints
            .map((pt, pointIdx) => `${pointIdx === 0 ? "M" : "L"}${pt.x.toFixed(2)} ${pt.y.toFixed(2)}`)
            .join(" ");
          return { org, color, plotPoints, path };
        });

      const lines = mainLineData
        .map((line) => `
            <path d="${line.path}" fill="none" stroke="${escapeHtml(line.color)}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" />
          `)
        .join("");

      const dayScale = 86400000;
      const trendLineData = [...byOrg.entries()]
        .sort((a, b) => a[0].localeCompare(b[0]))
        .map(([org, orgPoints]) => {
          if (orgPoints.length < 3) {
            return null;
          }
          const xValues = orgPoints.map((point) => point.launchDate.getTime() / dayScale);
          const yValues = orgPoints.map((point) => point.greenRate);
          const meanX = xValues.reduce((sum, value) => sum + value, 0) / xValues.length;
          const meanY = yValues.reduce((sum, value) => sum + value, 0) / yValues.length;
          let cov = 0;
          let varianceX = 0;
          for (let idx = 0; idx < xValues.length; idx += 1) {
            const dx = xValues[idx] - meanX;
            cov += dx * (yValues[idx] - meanY);
            varianceX += dx * dx;
          }
          if (varianceX <= 0) {
            return null;
          }
          const slope = cov / varianceX;
          const intercept = meanY - (slope * meanX);
          const startXValue = Math.min(...xValues);
          const endXValue = Math.max(...xValues);
          const startY = Math.max(0, Math.min(100, (slope * startXValue) + intercept));
          const endY = Math.max(0, Math.min(100, (slope * endXValue) + intercept));
          return {
            org,
            color: orgColor(org),
            x1: xFor(startXValue * dayScale),
            y1: yFor(startY),
            x2: xFor(endXValue * dayScale),
            y2: yFor(endY),
          };
        })
        .filter(Boolean);

      const trendLines = trendLineData
        .map((line) => `
            <line x1="${line.x1.toFixed(2)}" y1="${line.y1.toFixed(2)}" x2="${line.x2.toFixed(2)}" y2="${line.y2.toFixed(2)}" stroke="${escapeHtml(line.color)}" stroke-opacity="0.38" stroke-width="1.4" stroke-dasharray="4 5" />
          `)
        .join("");

      const plotSegments = [];
      mainLineData.forEach((line) => {
        for (let idx = 1; idx < line.plotPoints.length; idx += 1) {
          const prev = line.plotPoints[idx - 1];
          const curr = line.plotPoints[idx];
          plotSegments.push({ x1: prev.x, y1: prev.y, x2: curr.x, y2: curr.y, kind: "main" });
        }
      });
      trendLineData.forEach((line) => {
        plotSegments.push({ x1: line.x1, y1: line.y1, x2: line.x2, y2: line.y2, kind: "trend" });
      });

      const approxLabelWidth = (text) => Math.min(190, Math.max(34, text.length * 5.8 + 6));
      const clamp = (value, minValue, maxValue) => Math.min(maxValue, Math.max(minValue, value));
      const labelTopY = margin.top + 10;
      const labelBottomY = height - margin.bottom - 4;
      const labelHeight = chartPixelWidth <= 420 ? 14 : chartPixelWidth <= 560 ? 15 : 16;
      const labelPadX = 4;
      const labelPadY = 3;

      const labelBudget = chartPixelWidth <= 420 ? 8
        : chartPixelWidth <= 560 ? 11
          : chartPixelWidth <= 760 ? 14
            : chartPixelWidth <= 980 ? 18
              : Number.POSITIVE_INFINITY;
      const pointPriority = new Map();
      const pinnedPoints = new Set();
      byOrg.forEach((orgPoints) => {
        if (!orgPoints.length) {
          return;
        }
        const sorted = orgPoints.slice().sort((a, b) => a.launchDate.getTime() - b.launchDate.getTime());
        const bestPoint = sorted.reduce((best, point) => (point.greenRate > best.greenRate ? point : best), sorted[0]);
        const worstPoint = sorted.reduce((worst, point) => (point.greenRate < worst.greenRate ? point : worst), sorted[0]);
        pinnedPoints.add(sorted[0]);
        pinnedPoints.add(sorted[sorted.length - 1]);
        pinnedPoints.add(bestPoint);
        if (chartPixelWidth > 560) {
          pinnedPoints.add(worstPoint);
        }
        sorted.forEach((point, idx) => {
          const prev = idx > 0 ? sorted[idx - 1] : null;
          const next = idx < sorted.length - 1 ? sorted[idx + 1] : null;
          const changeBefore = prev ? Math.abs(point.greenRate - prev.greenRate) : 0;
          const changeAfter = next ? Math.abs(next.greenRate - point.greenRate) : 0;
          const slopeTurn = prev && next
            ? Math.abs((next.greenRate - point.greenRate) - (point.greenRate - prev.greenRate))
            : 0;
          const recency = sorted.length === 1 ? 1 : idx / (sorted.length - 1);
          const edgeBonus = idx === 0 || idx === sorted.length - 1 ? 18 : 0;
          const importance = (changeBefore + changeAfter) * 1.3
            + (slopeTurn * 0.6)
            + (point.greenRate * 0.07)
            + (recency * 7)
            + edgeBonus;
          pointPriority.set(point, importance);
        });
      });

      const selectedLabelPoints = (() => {
        if (!Number.isFinite(labelBudget) || points.length <= labelBudget) {
          return points.slice();
        }

        const selected = new Set();
        pinnedPoints.forEach((point) => selected.add(point));

        const minPerOrg = chartPixelWidth <= 560 ? 2 : 3;
        byOrg.forEach((orgPoints) => {
          const ranked = orgPoints
            .slice()
            .sort((a, b) => (
              (pointPriority.get(b) || 0) - (pointPriority.get(a) || 0)
              || a.launchDate.getTime() - b.launchDate.getTime()
            ));
          let count = orgPoints.filter((point) => selected.has(point)).length;
          for (const point of ranked) {
            if (count >= minPerOrg || selected.size >= labelBudget) {
              break;
            }
            if (!selected.has(point)) {
              selected.add(point);
              count += 1;
            }
          }
        });

        const rankedAll = points
          .slice()
          .sort((a, b) => (
            (pointPriority.get(b) || 0) - (pointPriority.get(a) || 0)
            || a.launchDate.getTime() - b.launchDate.getTime()
          ));
        for (const point of rankedAll) {
          if (selected.size >= labelBudget) {
            break;
          }
          selected.add(point);
        }

        if (selected.size > labelBudget) {
          const nonPinned = [...selected]
            .filter((point) => !pinnedPoints.has(point))
            .sort((a, b) => (
              (pointPriority.get(a) || 0) - (pointPriority.get(b) || 0)
              || a.launchDate.getTime() - b.launchDate.getTime()
            ));
          for (const point of nonPinned) {
            if (selected.size <= labelBudget) {
              break;
            }
            selected.delete(point);
          }
        }

        return points.filter((point) => selected.has(point));
      })();

      const entries = selectedLabelPoints.map((point) => ({
        point,
        px: xFor(point.launchDate.getTime()),
        py: yFor(point.greenRate),
        labelText: point.chartLabel || point.label,
        textWidth: approxLabelWidth(point.chartLabel || point.label),
        priority: pointPriority.get(point) || 0,
      }));

      entries.forEach((entry) => {
        let nearest = Infinity;
        entries.forEach((other) => {
          if (entry === other) {
            return;
          }
          const d = Math.hypot(entry.px - other.px, entry.py - other.py);
          if (d < nearest) {
            nearest = d;
          }
        });
        entry.crowd = Number.isFinite(nearest) ? nearest : 999;
      });

      const placementOrder = entries
        .slice()
        .sort((a, b) => a.crowd - b.crowd || b.priority - a.priority || b.px - a.px || a.py - b.py);

      const nearDx = chartPixelWidth <= 420 ? 6 : 8;
      const farDx = chartPixelWidth <= 420 ? 10 : 14;
      const nearDyUp = chartPixelWidth <= 420 ? -7 : -8;
      const nearDyDown = chartPixelWidth <= 420 ? 9 : 10;
      const midDyUp = chartPixelWidth <= 420 ? -9 : -11;
      const midDyDown = chartPixelWidth <= 420 ? 11 : 13;
      const candidateOffsets = [
        { dx: nearDx, dy: nearDyUp, anchor: "start", tier: 0 },
        { dx: nearDx, dy: nearDyDown, anchor: "start", tier: 0 },
        { dx: -nearDx, dy: nearDyUp, anchor: "end", tier: 0 },
        { dx: -nearDx, dy: nearDyDown, anchor: "end", tier: 0 },
        { dx: 0, dy: midDyUp, anchor: "middle", tier: 0 },
        { dx: 0, dy: midDyDown, anchor: "middle", tier: 0 },
        { dx: farDx, dy: midDyUp, anchor: "start", tier: 1 },
        { dx: farDx, dy: midDyDown, anchor: "start", tier: 1 },
        { dx: -farDx, dy: midDyUp, anchor: "end", tier: 1 },
        { dx: -farDx, dy: midDyDown, anchor: "end", tier: 1 },
      ];
      const labelManualNudge = (labelText) => {
        const canonical = String(labelText || "")
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, " ")
          .trim();
        if (canonical.includes("claude opus 4 6")) {
          return { dx: 4, dy: 4, preferAnchor: "start" };
        }
        if (canonical.includes("claude opus 4 5")) {
          return { dx: 3, dy: 4, preferAnchor: "start" };
        }
        if (canonical.includes("claude opus 4 1")) {
          return { dx: 2, dy: 3, preferAnchor: "start" };
        }
        if (canonical === "claude opus 4") {
          return { dx: 2, dy: 4, preferAnchor: "start" };
        }
        if (canonical.includes("gpt 5 1 chat")) {
          return { dx: -12, dy: -6, preferAnchor: "end" };
        }
        if (canonical.includes("gpt 5 2 codex")) {
          return { dx: 2, dy: -14, preferAnchor: "start" };
        }
        if (canonical === "gpt 5 2") {
          return { dx: 12, dy: -1, preferAnchor: "start" };
        }
        if (canonical.includes("gpt 5 3 codex")) {
          return { dx: 14, dy: 4, preferAnchor: "start" };
        }
        if (canonical.includes("gpt 5 codex")) {
          return { dx: 2, dy: 4, preferAnchor: "start" };
        }
        if (canonical.includes("gemini 3 pro")) {
          return { dx: 2, dy: 10, preferAnchor: "start", preferDown: true };
        }
        if (canonical.includes("gemini 3 1 pro")) {
          return { dx: 12, dy: 0, preferAnchor: "start" };
        }
        return { dx: 0, dy: 0 };
      };

      const labelBBox = (x, y, anchor, widthValue) => {
        const left = anchor === "start"
          ? x - labelPadX
          : anchor === "end"
            ? x - widthValue - labelPadX
            : x - (widthValue / 2) - labelPadX;
        const right = left + widthValue + (labelPadX * 2);
        return {
          left,
          right,
          top: y - labelHeight + labelPadY,
          bottom: y + labelPadY,
        };
      };

      const clampLabelX = (x, anchor, widthValue) => {
        if (anchor === "start") {
          return clamp(x, margin.left + 4, width - margin.right - widthValue - 4);
        }
        if (anchor === "end") {
          return clamp(x, margin.left + widthValue + 4, width - margin.right - 4);
        }
        return clamp(x, margin.left + (widthValue / 2) + 4, width - margin.right - (widthValue / 2) - 4);
      };

      const pointInRect = (x, y, rect) => (
        x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom
      );
      const orientation = (ax, ay, bx, by, cx, cy) => (
        ((bx - ax) * (cy - ay)) - ((by - ay) * (cx - ax))
      );
      const onSegment = (ax, ay, bx, by, cx, cy) => (
        Math.min(ax, bx) - 0.0001 <= cx
        && cx <= Math.max(ax, bx) + 0.0001
        && Math.min(ay, by) - 0.0001 <= cy
        && cy <= Math.max(ay, by) + 0.0001
      );
      const segmentsIntersect = (a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) => {
        const o1 = orientation(a1x, a1y, a2x, a2y, b1x, b1y);
        const o2 = orientation(a1x, a1y, a2x, a2y, b2x, b2y);
        const o3 = orientation(b1x, b1y, b2x, b2y, a1x, a1y);
        const o4 = orientation(b1x, b1y, b2x, b2y, a2x, a2y);

        if ((o1 > 0 && o2 < 0 || o1 < 0 && o2 > 0) && (o3 > 0 && o4 < 0 || o3 < 0 && o4 > 0)) {
          return true;
        }
        if (Math.abs(o1) < 0.0001 && onSegment(a1x, a1y, a2x, a2y, b1x, b1y)) {
          return true;
        }
        if (Math.abs(o2) < 0.0001 && onSegment(a1x, a1y, a2x, a2y, b2x, b2y)) {
          return true;
        }
        if (Math.abs(o3) < 0.0001 && onSegment(b1x, b1y, b2x, b2y, a1x, a1y)) {
          return true;
        }
        return Math.abs(o4) < 0.0001 && onSegment(b1x, b1y, b2x, b2y, a2x, a2y);
      };
      const segmentIntersectsRect = (x1, y1, x2, y2, rect) => {
        if (pointInRect(x1, y1, rect) || pointInRect(x2, y2, rect)) {
          return true;
        }
        const edges = [
          [rect.left, rect.top, rect.right, rect.top],
          [rect.right, rect.top, rect.right, rect.bottom],
          [rect.right, rect.bottom, rect.left, rect.bottom],
          [rect.left, rect.bottom, rect.left, rect.top],
        ];
        return edges.some((edge) => segmentsIntersect(x1, y1, x2, y2, edge[0], edge[1], edge[2], edge[3]));
      };

      const placed = [];
      placementOrder.forEach((entry) => {
        const manualNudge = labelManualNudge(entry.labelText);
        let best = null;
        candidateOffsets.forEach((candidate) => {
          const x = clampLabelX(entry.px + candidate.dx + manualNudge.dx, candidate.anchor, entry.textWidth);
          const y = clamp(entry.py + candidate.dy + manualNudge.dy, labelTopY, labelBottomY);
          const bbox = labelBBox(x, y, candidate.anchor, entry.textWidth);
          const connectorX = candidate.anchor === "start"
            ? x - 2
            : candidate.anchor === "end"
              ? x + 2
              : x;
          const lineLen = Math.hypot(connectorX - entry.px, y - entry.py);

          let overlapPenalty = 0;
          let proximityPenalty = 0;
          placed.forEach((other) => {
            const overlapX = Math.max(0, Math.min(bbox.right, other.bbox.right) - Math.max(bbox.left, other.bbox.left));
            const overlapY = Math.max(0, Math.min(bbox.bottom, other.bbox.bottom) - Math.max(bbox.top, other.bbox.top));
            if (overlapX > 0 && overlapY > 0) {
              overlapPenalty += 100000 + (overlapX * overlapY * 35);
              return;
            }
            const gapX = bbox.right < other.bbox.left
              ? other.bbox.left - bbox.right
              : bbox.left > other.bbox.right
                ? bbox.left - other.bbox.right
                : 0;
            const gapY = bbox.bottom < other.bbox.top
              ? other.bbox.top - bbox.bottom
              : bbox.top > other.bbox.bottom
                ? bbox.top - other.bbox.bottom
                : 0;
            if (gapX < 4 && gapY < 8) {
              proximityPenalty += (4 - gapX) * (8 - gapY) * 22;
            }
          });

          const expandedLabelRect = {
            left: bbox.left - 1.2,
            right: bbox.right + 1.2,
            top: bbox.top - 1.2,
            bottom: bbox.bottom + 1.2,
          };
          let lineOverlapPenalty = 0;
          plotSegments.forEach((seg) => {
            if (segmentIntersectsRect(seg.x1, seg.y1, seg.x2, seg.y2, expandedLabelRect)) {
              lineOverlapPenalty += seg.kind === "main" ? 320 : 160;
            }
          });

          const innerLeft = margin.left + (plotWidth * 0.15);
          const innerRight = margin.left + (plotWidth * 0.85);
          let edgeAnchorPenalty = 0;
          if (entry.px < innerLeft && candidate.anchor === "end") {
            edgeAnchorPenalty += 18;
          }
          if (entry.px > innerRight && candidate.anchor === "start") {
            edgeAnchorPenalty += 18;
          }

          let boundaryPenalty = 0;
          if (entry.py < margin.top + 24 && candidate.dy < 0) {
            boundaryPenalty += 10;
          }
          if (entry.py > (height - margin.bottom - 24) && candidate.dy > 0) {
            boundaryPenalty += 10;
          }

          let manualAnchorPenalty = 0;
          if (manualNudge.preferAnchor && candidate.anchor !== manualNudge.preferAnchor) {
            manualAnchorPenalty += 18;
          }
          let manualVerticalPenalty = 0;
          if (manualNudge.preferDown && candidate.dy < 0) {
            manualVerticalPenalty += 24;
          }
          if (manualNudge.preferUp && candidate.dy > 0) {
            manualVerticalPenalty += 24;
          }

          const score = overlapPenalty
            + proximityPenalty
            + lineOverlapPenalty
            + edgeAnchorPenalty
            + boundaryPenalty
            + manualAnchorPenalty
            + manualVerticalPenalty
            + (lineLen * 1.6)
            + (Math.abs(candidate.dy) * 0.9)
            + (candidate.tier * 18);
          if (!best || score < best.score) {
            best = {
              ...entry,
              anchor: candidate.anchor,
              x,
              y,
              bbox,
              connectorX,
              lineLen,
              score,
            };
          }
        });

        if (best) {
          placed.push(best);
        }
      });

      const placementByPoint = new Map(placed.map((entry) => [entry.point, entry]));
      const labelFontSize = chartPixelWidth <= 420 ? 10.4 : chartPixelWidth <= 560 ? 11 : 12;
      const labelNodes = [];
      selectedLabelPoints.forEach((point) => {
        const entry = placementByPoint.get(point);
        if (!entry) {
          return;
        }
        const labelColor = orgColor(entry.point.org);
        if (entry.lineLen > 5) {
          labelNodes.push(`
            <path d="M${entry.px.toFixed(2)} ${entry.py.toFixed(2)} L${entry.connectorX.toFixed(2)} ${entry.y.toFixed(2)}" fill="none" stroke="#8aa09a" stroke-opacity="0.55" stroke-width="0.9" />
          `);
        }
        labelNodes.push(`
          <text x="${entry.x.toFixed(2)}" y="${entry.y.toFixed(2)}" text-anchor="${entry.anchor}" fill="${escapeHtml(labelColor)}" font-size="${labelFontSize.toFixed(1)}" stroke="#f4faf7" stroke-width="2.6" paint-order="stroke fill">${escapeHtml(entry.labelText)}</text>
        `);
      });
      const pointLabels = labelNodes.join("");

      const orgLabelFontSize = chartPixelWidth <= 420 ? 11 : 12.4;
      const orgLabelPadX = chartPixelWidth <= 420 ? 4.8 : 5.6;
      const orgLabelPadY = chartPixelWidth <= 420 ? 2.8 : 3.2;
      const orgLabelHeight = orgLabelFontSize + (orgLabelPadY * 2);
      const orgLabelGap = orgLabelHeight + (chartPixelWidth <= 420 ? 2 : 3);
      const orgLabelRight = width - 6;
      const orgLabelTop = margin.top + (orgLabelHeight / 2) + 1;
      const orgLabelBottom = (height - margin.bottom) - (orgLabelHeight / 2) - 1;
      const orgLabelWidth = (text) => (
        Math.min(138, Math.max(56, (text.length * (orgLabelFontSize * 0.62)) + 8))
      );

      const orgEndLabels = [...byOrg.entries()]
        .map(([org, orgPoints]) => {
          const latest = orgPoints[orgPoints.length - 1];
          if (!latest) {
            return null;
          }
          return {
            org,
            text: displayOrg(org).toUpperCase(),
            color: orgColor(org),
            sourceX: xFor(latest.launchDate.getTime()),
            sourceY: yFor(latest.greenRate),
            y: yFor(latest.greenRate),
          };
        })
        .filter(Boolean)
        .sort((a, b) => a.y - b.y);

      if (orgEndLabels.length) {
        orgEndLabels[0].y = clamp(orgEndLabels[0].y, orgLabelTop, orgLabelBottom);
        for (let idx = 1; idx < orgEndLabels.length; idx += 1) {
          const targetY = clamp(orgEndLabels[idx].y, orgLabelTop, orgLabelBottom);
          orgEndLabels[idx].y = Math.max(targetY, orgEndLabels[idx - 1].y + orgLabelGap);
        }

        if (orgEndLabels[orgEndLabels.length - 1].y > orgLabelBottom) {
          orgEndLabels[orgEndLabels.length - 1].y = orgLabelBottom;
          for (let idx = orgEndLabels.length - 2; idx >= 0; idx -= 1) {
            orgEndLabels[idx].y = Math.min(orgEndLabels[idx].y, orgEndLabels[idx + 1].y - orgLabelGap);
          }
        }
        if (orgEndLabels[0].y < orgLabelTop) {
          orgEndLabels[0].y = orgLabelTop;
          for (let idx = 1; idx < orgEndLabels.length; idx += 1) {
            orgEndLabels[idx].y = Math.max(orgEndLabels[idx].y, orgEndLabels[idx - 1].y + orgLabelGap);
          }
        }
      }

      const orgLineLabels = orgEndLabels
        .map((entry) => {
          const textWidth = orgLabelWidth(entry.text);
          const boxWidth = textWidth + (orgLabelPadX * 2);
          const boxX = orgLabelRight - boxWidth;
          const boxY = entry.y - (orgLabelHeight / 2);
          const connectorX = boxX - 4;
          const startX = Math.min(entry.sourceX + 5, connectorX - 2);
          return `
            <path d="M${startX.toFixed(2)} ${entry.sourceY.toFixed(2)} L${connectorX.toFixed(2)} ${entry.y.toFixed(2)}" fill="none" stroke="${escapeHtml(entry.color)}" stroke-opacity="0.62" stroke-width="1.2" />
            <rect x="${boxX.toFixed(2)}" y="${boxY.toFixed(2)}" width="${boxWidth.toFixed(2)}" height="${orgLabelHeight.toFixed(2)}" rx="3.8" ry="3.8" fill="#ffffff" fill-opacity="0.88" stroke="${escapeHtml(entry.color)}" stroke-opacity="0.7" stroke-width="1.1" />
            <text x="${(boxX + orgLabelPadX).toFixed(2)}" y="${(entry.y + (orgLabelFontSize * 0.33)).toFixed(2)}" text-anchor="start" fill="${escapeHtml(entry.color)}" font-size="${orgLabelFontSize.toFixed(1)}" font-weight="700" letter-spacing="0.35">${escapeHtml(entry.text)}</text>
          `;
        })
        .join("");

      const circles = points
        .sort((a, b) => a.launchDate.getTime() - b.launchDate.getTime() || a.org.localeCompare(b.org))
        .map((point) => {
          const cx = xFor(point.launchDate.getTime());
          const cy = yFor(point.greenRate);
          const color = orgColor(point.org);
          const evidenceText = point.evidenceUrl ? ` | ${point.evidenceUrl}` : "";
          const title = `${displayOrg(point.org)} | ${point.chartLabel || point.label} | ${point.launchDateText} | Green ${point.greenRate.toFixed(1)}%${evidenceText}`;
          return `
            <circle cx="${cx.toFixed(2)}" cy="${cy.toFixed(2)}" r="5.2" fill="${escapeHtml(color)}" fill-opacity="0.9" stroke="#17211e" stroke-opacity="0.4" stroke-width="0.9">
              <title>${escapeHtml(title)}</title>
            </circle>
          `;
        })
        .join("");

      el.launchScatterSvg.innerHTML = `
        ${gridY}
        ${gridX}
        ${trendLines}
        ${lines}
        ${pointLabels}
        ${circles}
        ${orgLineLabels}
        <text x="${(margin.left + plotWidth / 2).toFixed(2)}" y="${(height - 14).toFixed(2)}" text-anchor="middle" fill="#425851" font-size="${axisFontSize.toFixed(1)}">Model Launch Date</text>
        <text x="16" y="${(margin.top + plotHeight / 2).toFixed(2)}" transform="rotate(-90,16,${(margin.top + plotHeight / 2).toFixed(2)})" text-anchor="middle" fill="#425851" font-size="${axisFontSize.toFixed(1)}">% Clear Pushback (Green)</text>
      `;

      el.launchScatterMeta.textContent = "Note: Percentage of time the model scored 'Green' (pushed back clearly). Best score only if multiple models from the same release were tested (e.g. multiple reasoning levels).";
    }

    function renderChartDrilldown(filteredRows) {
      if (!el.chartDrilldownPanel || !el.chartDrilldownBody) {
        return;
      }
      const selected = state.chartDrilldown;
      if (!selected || !selected.modelKey || !selected.category || !CATEGORY_META[selected.category]) {
        el.chartDrilldownPanel.classList.add("hidden-block");
        el.chartDrilldownBody.innerHTML = "";
        return;
      }

      const modelSample = filteredRows.find((row) => modelKey(row) === selected.modelKey)
        || state.rows.find((row) => modelKey(row) === selected.modelKey);
      if (!modelSample) {
        state.chartDrilldown = null;
        el.chartDrilldownPanel.classList.add("hidden-block");
        el.chartDrilldownBody.innerHTML = "";
        return;
      }

      const matches = filteredRows
        .filter((row) => modelKey(row) === selected.modelKey && categoryKey(row) === selected.category)
        .sort((a, b) => String(a.question_id || "").localeCompare(String(b.question_id || "")));
      const categoryMeta = CATEGORY_META[selected.category];
      const modelLabel = displayModel(modelSample);
      el.chartDrilldownTitle.textContent = `BullshitBench: ${modelLabel} Â· ${categoryMeta.label}`;
      el.chartDrilldownMeta.textContent = `${matches.length} matching responses`;

      if (!matches.length) {
        el.chartDrilldownBody.innerHTML = `<p class="subtle">No matching rows under the current filters.</p>`;
      } else {
        el.chartDrilldownBody.innerHTML = matches
          .map((row) => {
            const responseText = row.response_text || row.error || "No response text.";
            const metaBits = [
              row.question_id || "unknown",
              displayTechnique(row.technique || "unknown"),
              row.domain || "unknown",
            ];
            return `
              <article class="drilldown-item">
                <div class="meta">
                  <span class="pill ${categoryMeta.colorClass}">${escapeHtml(categoryMeta.label)}</span>
                  <span>${escapeHtml(metaBits.join(" Â· "))}</span>
                </div>
                <p class="question">${escapeHtml(row.question || "")}</p>
                <p class="response">${escapeHtml(responseText)}</p>
              </article>
            `;
          })
          .join("");
      }
      el.chartDrilldownPanel.classList.remove("hidden-block");
    }

    function defaultLeaderboardCompare(a, b) {
      if (b.greenRate !== a.greenRate) {
        return b.greenRate - a.greenRate;
      }
      if (a.redRate !== b.redRate) {
        return a.redRate - b.redRate;
      }
      return a.model.localeCompare(b.model);
    }

    function updateLeaderboardSortIndicators() {
      const indicators = document.querySelectorAll("[data-sort-ind]");
      indicators.forEach((node) => {
        const key = node.getAttribute("data-sort-ind");
        if (key === state.leaderboardSort.key) {
          node.textContent = state.leaderboardSort.direction === "asc" ? "â–²" : "â–¼";
        } else {
          node.textContent = "";
        }
      });
    }

    function renderLeaderboard(filteredRows) {
      const byModel = groupBy(filteredRows, (row) => modelKey(row));
      const rows = [...byModel.entries()].map(([key, modelRows]) => {
        const sample = modelRows[0] || {};
        const stats = summarizeRows(modelRows);
        const launch = launchMetadataForRow(sample);
        const launchDate = launch ? String(launch.launch_date || "").trim() : "";
        const launchEvidenceUrl = launch ? String(launch.evidence_url || "").trim() : "";
        const modelAgeDays = modelAgeDaysForRow(sample);
        return {
          key,
          rank: 0,
          model: displayModel(sample),
          org: modelOrg(sample),
          reasoning: normalizeReasoningLevel(sample.model_reasoning_level),
          launchDate,
          launchEvidenceUrl,
          modelAgeDays,
          ...stats,
        };
      });

      const baseline = [...rows].sort(defaultLeaderboardCompare);
      baseline.forEach((row, idx) => {
        row.rank = idx + 1;
      });

      const { key, direction } = state.leaderboardSort;
      const numericKeys = new Set([
        "rank",
        "greenRate",
        "amberRate",
        "redRate",
        "errorRate",
        "rows",
        "modelAgeDays",
      ]);
      const dir = direction === "asc" ? 1 : -1;
      baseline.sort((a, b) => {
        let cmp = 0;
        if (key === "launchDate") {
          const dateA = parseIsoDate(a.launchDate);
          const dateB = parseIsoDate(b.launchDate);
          if (dateA && dateB) {
            cmp = dateA.getTime() - dateB.getTime();
          } else if (dateA) {
            cmp = -1;
          } else if (dateB) {
            cmp = 1;
          } else {
            cmp = 0;
          }
        } else if (numericKeys.has(key)) {
          cmp = Number(a[key] || 0) - Number(b[key] || 0);
        } else {
          cmp = String(a[key] || "").localeCompare(String(b[key] || ""));
        }
        if (cmp !== 0) {
          return cmp * dir;
        }
        return defaultLeaderboardCompare(a, b);
      });

      el.leaderboardBody.innerHTML = baseline
        .map((row) => {
          const orgSwatch = orgColor(row.org);
          const mixTotal = row.rows || 1;
          const mix = CATEGORY_ORDER
            .map((key) => {
              return `<span class="mix-seg ${CATEGORY_META[key].colorClass}" style="width:${pct(row.counts[key], mixTotal).toFixed(2)}%;"></span>`;
            })
            .join("");
          const reasoningLabel =
            row.reasoning && row.reasoning !== "none"
              ? row.reasoning.charAt(0).toUpperCase() + row.reasoning.slice(1)
              : "None";
          const launchDateText = row.launchDate || "Unknown";
          const launchDateCell = row.launchEvidenceUrl
            ? `<a href="${escapeHtml(row.launchEvidenceUrl)}" target="_blank" rel="noreferrer">${escapeHtml(launchDateText)}</a>`
            : escapeHtml(launchDateText);
          const modelAgeText = Number.isFinite(row.modelAgeDays) ? String(row.modelAgeDays) : "Unknown";
          return `
            <tr>
              <td>${row.rank}</td>
              <td>
                <div class="model-name model-name-with-org">
                  <span class="org-dot" style="background:${escapeHtml(orgSwatch)};"></span>
                  <span>${escapeHtml(row.model)}</span>
                </div>
              </td>
              <td>
                <span class="org-chip">
                  <span class="org-dot" style="background:${escapeHtml(orgSwatch)};"></span>
                  ${escapeHtml(displayOrg(row.org))}
                </span>
              </td>
              <td>${escapeHtml(reasoningLabel)}</td>
              <td>${launchDateCell}</td>
              <td>${escapeHtml(modelAgeText)}</td>
              <td>${formatPct(row.greenRate)}</td>
              <td>${formatPct(row.amberRate)}</td>
              <td>${formatPct(row.redRate)}</td>
              <td>${formatPct(row.errorRate)}</td>
              <td class="mix-cell">
                <div class="mini-mix">${mix}</div>
              </td>
              <td>${row.rows}</td>
            </tr>
          `;
        })
        .join("");
      updateLeaderboardSortIndicators();
    }

    function questionBandMatches(correctPct, band) {
      const pctValue = Number(correctPct || 0);
      if (band === "80_100") {
        return pctValue >= 80;
      }
      if (band === "60_80") {
        return pctValue >= 60 && pctValue < 80;
      }
      if (band === "40_60") {
        return pctValue >= 40 && pctValue < 60;
      }
      if (band === "20_40") {
        return pctValue >= 20 && pctValue < 40;
      }
      if (band === "0_20") {
        return pctValue < 20;
      }
      return true;
    }

    function getQuestionEntries(filteredRows) {
      return getQuestionGroups(filteredRows, false)
        .map(([questionId, rows]) => {
          const sample = rows[0] || {};
          const stats = summarizeRows(rows);
          return {
            questionId,
            rows,
            sample,
            correctPct: stats.greenRate,
            scored: stats.scored,
            hasGreen: rows.some((row) => categoryKey(row) === "green"),
            hasRed: rows.some((row) => categoryKey(row) === "red"),
          };
        })
        .sort((a, b) =>
          b.correctPct - a.correctPct
          || a.questionId.localeCompare(b.questionId),
        );
    }

    function getBandFilteredQuestionEntries(filteredRows, requirePairs = false) {
      const band = (el.compareQuestionBand && el.compareQuestionBand.value) || "all";
      const entries = getQuestionEntries(filteredRows)
        .filter((entry) => questionBandMatches(entry.correctPct, band));
      if (!requirePairs) {
        return entries;
      }
      return entries.filter((entry) => entry.rows.length >= 2);
    }

    function renderQuestionOptions(filteredRows) {
      const entries = getBandFilteredQuestionEntries(filteredRows, false);
      const prev = el.compareQuestion.value;
      el.compareQuestion.innerHTML = entries
        .map((entry) => {
          const row = entry.sample;
          const label = `${entry.questionId} Â· ${formatPct(entry.correctPct)} correct Â· ${displayTechnique(row.technique)} Â· ${row.domain || "unknown"}`;
          return `<option value="${escapeHtml(entry.questionId)}">${escapeHtml(label)}</option>`;
        })
        .join("");
      let changed = false;
      if (prev && entries.some((entry) => entry.questionId === prev)) {
        el.compareQuestion.value = prev;
      } else if (entries[0]) {
        el.compareQuestion.value = entries[0].questionId;
        changed = true;
      } else {
        changed = true;
      }
      if (changed) {
        // Reset selections so a new default question starts with a fresh contrast pair.
        el.compareModelA.value = "";
        el.compareModelB.value = "";
      }
    }

    function getQuestionRows(filteredRows) {
      const questionId = el.compareQuestion.value;
      return filteredRows.filter((row) => String(row.question_id || "") === questionId);
    }

    function renderQuestionContext(questionRows) {
      if (!questionRows.length) {
        el.questionContext.innerHTML = `<p class="subtle">No rows match the selected filters for this question.</p>`;
        return;
      }
      const base = questionRows[0];
      el.questionContext.innerHTML = `
        <p class="question">${escapeHtml(base.question || "")}</p>
      `;
    }

    function fillCompareModels(questionRows) {
      const models = collectModelInfos(questionRows);
      const existingA = el.compareModelA.value;
      const existingB = el.compareModelB.value;
      const modelOptions = models
        .map(
          (item) =>
            `<option value="${escapeHtml(item.key)}">${escapeHtml(item.label)}</option>`,
        )
        .join("");
      el.compareModelA.innerHTML = modelOptions;
      el.compareModelB.innerHTML = modelOptions;

      if (models.some((m) => m.key === existingA)) {
        el.compareModelA.value = existingA;
      }
      if (models.some((m) => m.key === existingB)) {
        el.compareModelB.value = existingB;
      }

      const questionId = String(el.compareQuestion.value || "");
      const questionChanged = questionId !== state.lastCompareQuestionId;
      const byKey = new Map(questionRows.map((row) => [modelKey(row), row]));
      const existingRowA = byKey.get(el.compareModelA.value);
      const existingRowB = byKey.get(el.compareModelB.value);
      const hasValidExistingPair = Boolean(
        existingRowA && existingRowB && modelKey(existingRowA) !== modelKey(existingRowB),
      );
      const pickGreenRedPair = () => {
        const greens = questionRows.filter((row) => categoryKey(row) === "green");
        const reds = questionRows.filter((row) => categoryKey(row) === "red");
        if (greens.length && reds.length) {
          const strictPairs = [];
          greens.forEach((greenRow) => {
            reds.forEach((redRow) => {
              if (
                modelKey(greenRow) !== modelKey(redRow)
                && baseModelIdFromRow(greenRow) !== baseModelIdFromRow(redRow)
              ) {
                strictPairs.push([greenRow, redRow]);
              }
            });
          });
          if (strictPairs.length) {
            return randomItem(strictPairs);
          }
          const greenPick = randomItem(greens);
          const redPick = randomItem(reds);
          if (greenPick && redPick && modelKey(greenPick) !== modelKey(redPick)) {
            return [greenPick, redPick];
          }
        }
        return null;
      };
      const pickBestWorstPair = () => {
        if (questionRows.length < 2) {
          return null;
        }
        const best = [...questionRows].sort((a, b) => categoryRank(categoryKey(b)) - categoryRank(categoryKey(a)))[0];
        const worst = [...questionRows].sort((a, b) => categoryRank(categoryKey(a)) - categoryRank(categoryKey(b)))[0];
        if (best && worst && modelKey(best) !== modelKey(worst)) {
          return [best, worst];
        }
        return null;
      };

      const shouldSeedContrastPair = !el.compareModelA.value
        || !el.compareModelB.value
        || (questionChanged && !hasValidExistingPair);
      if (shouldSeedContrastPair) {
        const pair = pickGreenRedPair() || pickBestWorstPair();
        if (pair) {
          el.compareModelA.value = modelKey(pair[0]);
          el.compareModelB.value = modelKey(pair[1]);
        }
      }

      if (!el.compareModelA.value && models.length > 0) {
        el.compareModelA.value = models[0].key;
      }
      if (!el.compareModelB.value) {
        const fallback = models.find((m) => m.key !== el.compareModelA.value);
        el.compareModelB.value = fallback ? fallback.key : (models[0] ? models[0].key : "");
      }
      if (el.compareModelA.value && el.compareModelA.value === el.compareModelB.value && models.length > 1) {
        const fallback = models.find((m) => m.key !== el.compareModelA.value);
        if (fallback) {
          el.compareModelB.value = fallback.key;
        }
      }

      if (!byKey.has(el.compareModelA.value) && models.length > 0) {
        el.compareModelA.value = models[0].key;
      }
      if (!byKey.has(el.compareModelB.value) && models.length > 1) {
        const fallback = models.find((m) => m.key !== el.compareModelA.value);
        el.compareModelB.value = fallback ? fallback.key : models[0].key;
      }
      state.lastCompareQuestionId = questionId;
    }

    function renderSingleResponseCard(row, titlePrefix = "") {
      if (!row) {
        return `<div class="response-card error"><p class="subtle">No model selected.</p></div>`;
      }
      const category = categoryKey(row);
      const org = modelOrg(row);
      const orgSwatch = orgColor(org);
      const judgeTooltip = [1, 2, 3]
        .map((idx) => {
          const score = row[`judge_${idx}_score`];
          const just = row[`judge_${idx}_justification`];
          const verdict = CATEGORY_META[categoryFromScore(score)].short;
          if (just) {
            return `J${idx}: ${verdict} - ${just}`;
          }
          return `J${idx}: ${verdict}`;
        })
        .join(" | ");
      const responseText = row.response_text || row.error || "No response text.";
      return `
        <article class="response-card ${CATEGORY_META[category].colorClass}" title="${escapeHtml(judgeTooltip)}">
          <div class="response-head">
            <h4 class="title model-title-with-org">
              <span class="org-dot" style="background:${escapeHtml(orgSwatch)};"></span>
              ${escapeHtml(titlePrefix)}${escapeHtml(displayModel(row))}
              <span class="org-chip">${escapeHtml(displayOrg(org))}</span>
            </h4>
            <span class="pill ${CATEGORY_META[category].colorClass}">${escapeHtml(CATEGORY_META[category].short)}</span>
          </div>
          <p class="response-text">${escapeHtml(responseText)}</p>
        </article>
      `;
    }

    function randomItem(items) {
      if (!items.length) {
        return null;
      }
      return items[Math.floor(Math.random() * items.length)];
    }

    function pickPairFromRows(rows, mode = "any") {
      if (!rows || rows.length < 2) {
        return null;
      }
      const differentBaseModel = (a, b) => {
        if (!a || !b) {
          return false;
        }
        if (modelKey(a) === modelKey(b)) {
          return false;
        }
        const baseA = baseModelIdFromRow(a);
        const baseB = baseModelIdFromRow(b);
        return !baseA || !baseB || baseA !== baseB;
      };
      const greens = rows.filter((row) => categoryKey(row) === "green");
      const reds = rows.filter((row) => categoryKey(row) === "red");

      if (mode === "green_red" && greens.length && reds.length) {
        const strictPairs = [];
        greens.forEach((greenRow) => {
          reds.forEach((redRow) => {
            if (differentBaseModel(greenRow, redRow)) {
              strictPairs.push([greenRow, redRow]);
            }
          });
        });
        if (strictPairs.length) {
          return randomItem(strictPairs);
        }
        const a = randomItem(greens);
        const b = randomItem(reds);
        if (a && b && modelKey(a) !== modelKey(b)) {
          return [a, b];
        }
      }

      if (mode === "green_red") {
        const best = [...rows].sort((a, b) => categoryRank(categoryKey(b)) - categoryRank(categoryKey(a)))[0];
        const worst = [...rows].sort((a, b) => categoryRank(categoryKey(a)) - categoryRank(categoryKey(b)))[0];
        if (best && worst && differentBaseModel(best, worst)) {
          return [best, worst];
        }
      }

      const i = Math.floor(Math.random() * rows.length);
      let j = Math.floor(Math.random() * rows.length);
      while (j === i && rows.length > 1) {
        j = Math.floor(Math.random() * rows.length);
      }
      if (rows[i] && rows[j] && differentBaseModel(rows[i], rows[j])) {
        return [rows[i], rows[j]];
      }
      const fallback = rows.filter((row) => differentBaseModel(row, rows[i]));
      if (fallback.length) {
        return [rows[i], fallback[0]];
      }
      return null;
    }

    function getQuestionGroups(sourceRows, requirePairs = false) {
      const groups = new Map();
      sourceRows.forEach((row) => {
        if (!row.question_id) {
          return;
        }
        if (!groups.has(row.question_id)) {
          groups.set(row.question_id, []);
        }
        groups.get(row.question_id).push(row);
      });
      const entries = [...groups.entries()];
      if (!requirePairs) {
        return entries;
      }
      return entries.filter(([, rows]) => rows.length >= 2);
    }

    function applyQuestionSelection(questionId, rows, pairMode = "any") {
      if (!questionId) {
        return false;
      }
      el.compareQuestion.value = questionId;
      const pair = pickPairFromRows(rows, pairMode) || pickPairFromRows(rows, "any");
      if (pair) {
        el.compareModelA.value = modelKey(pair[0]);
        el.compareModelB.value = modelKey(pair[1]);
      }
      renderAll();
      return true;
    }

    function randomizeQuestionPair(mode = "any") {
      const candidates = getBandFilteredQuestionEntries(state.filteredRows || [], true).filter((entry) => {
        if (mode !== "green_red") {
          return true;
        }
        return entry.hasGreen && entry.hasRed;
      });
      if (!candidates.length) {
        return;
      }

      const selected = randomItem(candidates);
      if (!selected) {
        return;
      }
      if (!applyQuestionSelection(selected.questionId, selected.rows, mode)) {
        return;
      }
    }

    function randomizeRankedQuestion(mode = "best") {
      const candidates = getBandFilteredQuestionEntries(state.filteredRows || [], true)
        .filter((entry) => entry.scored > 0)
        .map((entry) => {
          const stats = summarizeRows(entry.rows);
          return {
            questionId: entry.questionId,
            rows: entry.rows,
            greenRate: stats.greenRate,
            redRate: stats.redRate,
            amberRate: stats.amberRate,
            scored: stats.scored,
          };
        });
      if (!candidates.length) {
        return;
      }

      if (mode === "worst") {
        candidates.sort((a, b) =>
          b.redRate - a.redRate
          || a.greenRate - b.greenRate
          || b.scored - a.scored
          || a.questionId.localeCompare(b.questionId),
        );
      } else {
        candidates.sort((a, b) =>
          b.greenRate - a.greenRate
          || a.redRate - b.redRate
          || b.scored - a.scored
          || a.questionId.localeCompare(b.questionId),
        );
      }

      const bucketSize = Math.max(1, Math.min(12, Math.ceil(candidates.length * 0.2)));
      const pool = candidates.slice(0, bucketSize);
      const selected = randomItem(pool);
      if (!selected) {
        return;
      }
      applyQuestionSelection(
        selected.questionId,
        selected.rows,
        mode === "worst" ? "green_red" : "any",
      );
    }

    function renderCompareSection(filteredRows) {
      renderQuestionOptions(filteredRows);
      const questionRows = getQuestionRows(filteredRows);
      state.questionRows = questionRows;
      renderQuestionContext(questionRows);
      fillCompareModels(questionRows);
      const viewMode = el.compareViewMode.value || "pair";
      const showAll = viewMode === "all";

      const questionEntries = getBandFilteredQuestionEntries(filteredRows, false);
      const hasAnyPair = questionEntries.some((entry) => entry.rows.length >= 2);
      const hasGreenRedPair = questionEntries.some((entry) => entry.rows.length >= 2 && entry.hasGreen && entry.hasRed);
      el.randomGreenRedBtn.disabled = !hasGreenRedPair;
      el.randomBestQuestionBtn.disabled = !hasAnyPair;
      el.randomWorstQuestionBtn.disabled = !hasAnyPair;

      const byModel = new Map();
      questionRows.forEach((row) => byModel.set(modelKey(row), row));
      el.compareModelA.disabled = showAll;
      el.compareModelB.disabled = showAll;

      const rowA = byModel.get(el.compareModelA.value);
      const rowB = byModel.get(el.compareModelB.value);
      if (showAll) {
        el.pairGrid.classList.add("hidden-block");
        const sortedRows = [...questionRows].sort((a, b) => {
          const rankCmp = categoryRank(categoryKey(b)) - categoryRank(categoryKey(a));
          if (rankCmp !== 0) {
            return rankCmp;
          }
          return displayModel(a).localeCompare(displayModel(b));
        });
        el.allResponsesGrid.classList.remove("hidden-block");
        el.allResponsesGrid.innerHTML = sortedRows.length
          ? sortedRows.map((row) => renderSingleResponseCard(row)).join("")
          : `<div class="response-card error"><p class="subtle">No responses for this question.</p></div>`;
      } else {
        el.allResponsesGrid.classList.add("hidden-block");
        el.allResponsesGrid.innerHTML = "";
        el.pairGrid.classList.remove("hidden-block");
        el.modelACard.innerHTML = renderSingleResponseCard(rowA, "A Â· ");
        el.modelBCard.innerHTML = renderSingleResponseCard(rowB, "B Â· ");
      }
    }

    function refreshFilterOptions() {
      fillSelect(el.filterOrg, uniqSorted(state.rows.map((r) => modelOrg(r))), "all", displayOrg);
      const modelInfos = collectModelInfos(state.rows);
      renderModelToggleGrid(modelInfos);
      fillSelect(el.filterReasoning, uniqSorted(state.rows.map((r) => reasoningFilterLevel(r.model_reasoning_level))));
      fillSelect(
        el.filterTechnique,
        uniqSorted(state.rows.map((r) => r.technique || "unknown")),
        "all",
        displayTechnique,
      );
      fillSelect(el.filterDomain, uniqSorted(state.rows.map((r) => r.domain || "unknown")));
    }

    function renderAll() {
      if (!state.rows.length) {
        return;
      }
      const scopedRows = applyFilters(state.rows, { ignoreOrgFilter: true });
      const filteredRows = applyFilters(state.rows);
      state.filteredRows = filteredRows;
      setDataState(`Showing ${filteredRows.length} of ${state.rows.length} rows.`);
      renderOrgColorKey(scopedRows);
      renderMainChartOrgGuide(scopedRows);
      renderSimpleModelBars(filteredRows);
      renderLaunchScatter(state.rows);
      renderChartDrilldown(filteredRows);
      renderLeaderboard(filteredRows);
      renderCompareSection(filteredRows);
    }

    function ingestData(payload) {
      state.responses = payload.responses;
      state.collectionStats = payload.collectionStats;
      state.panelSummary = payload.panelSummary;
      state.aggregateSummary = payload.aggregateSummary;
      state.aggregateRows = payload.aggregateRows;
      state.launchMetadataRows = payload.launchMetadataRows || [];
      state.launchByModel = new Map(
        state.launchMetadataRows
          .map((row) => {
            const modelId = String((row && row.model_id) || "").trim();
            if (!modelId) {
              return null;
            }
            return [modelId, row];
          })
          .filter(Boolean),
      );
      state.rows = normalizeRows(payload.aggregateRows, payload.responses);
      state.bySampleId = new Map(state.rows.map((row) => [row.sample_id, row]));
      state.lastCompareQuestionId = "";
      refreshJudgeFilterLabels();
      state.primaryModelKeys = computePrimaryModelKeys(state.rows);
      refreshFilterOptions();
      renderAll();
    }

    async function loadDefaultData() {
      const paths = resolvedDefaultPaths();
      try {
        const required = await Promise.all([
          fetchText(paths.responses),
          fetchText(paths.collectionStats),
          fetchText(paths.panelSummary),
          fetchText(paths.aggregateSummary),
        ]);

        let aggregateRowsText = "";
        try {
          aggregateRowsText = await fetchText(paths.aggregateRows);
        } catch (error) {
          setDataState("Loaded core files. Aggregate rows are missing, so comparison detail is limited.");
        }

        let launchMetadataText = "";
        try {
          launchMetadataText = await fetchText(paths.launchMetadata);
        } catch (_error) {
          launchMetadataText = "";
        }

        const payload = {
          responses: parseJsonl(required[0], "responses.jsonl"),
          collectionStats: JSON.parse(required[1]),
          panelSummary: JSON.parse(required[2]),
          aggregateSummary: JSON.parse(required[3]),
          aggregateRows: aggregateRowsText ? parseJsonl(aggregateRowsText, "aggregate.jsonl") : [],
          launchMetadataRows: launchMetadataText ? parseCsv(launchMetadataText, "model_launch_dates.csv") : [],
        };
        ingestData(payload);
        setDataState(
          `Loaded ${payload.responses.length} responses. `
          + `Launch metadata rows: ${payload.launchMetadataRows.length}.`,
        );
      } catch (error) {
        setDataState(`Could not load benchmark files: ${error.message}`);
      }
    }

    function resetFilters() {
      el.filterOrg.value = "all";
      el.filterReasoning.value = "all";
      el.filterTechnique.value = "all";
      el.filterDomain.value = "all";
      el.judge1Toggle.checked = true;
      el.judge2Toggle.checked = true;
      if (!el.judge3Toggle.disabled) {
        el.judge3Toggle.checked = true;
      }
      syncSelectedJudgesFromUI();
      state.hiddenModels.clear();
      state.primaryOnly = false;
      el.filterModelToggleSearch.value = "";
      el.filterQuery.value = "";
      if (el.launchBestOnlyToggle) {
        el.launchBestOnlyToggle.checked = true;
      }
      [...document.querySelectorAll('input[name="scoreFilter"]')].forEach((node) => {
        node.checked = true;
      });
      state.primaryModelKeys = computePrimaryModelKeys(state.rows);
      state.lastCompareQuestionId = "";
      renderModelToggleGrid(collectModelInfos(state.rows));
      renderAll();
    }

    function bindEvents() {
      const bindOrgToggle = (container) => {
        if (!container) {
          return;
        }
        const getToggledOrg = (event) => {
          const target = event.target;
          if (!(target instanceof Element)) {
            return "";
          }
          const chip = target.closest("[data-org-toggle]");
          return chip ? String(chip.getAttribute("data-org-toggle") || "") : "";
        };
        const toggleOrg = (org) => {
          if (!org) {
            return;
          }
          const currentOrg = String(el.filterOrg.value || "all");
          el.filterOrg.value = currentOrg === org ? "all" : org;
          renderAll();
        };
        container.addEventListener("click", (event) => {
          const org = getToggledOrg(event);
          if (!org) {
            return;
          }
          toggleOrg(org);
        });
      };

      el.clearFiltersBtn.addEventListener("click", resetFilters);
      bindOrgToggle(el.mainChartOrgGuide);
      bindOrgToggle(el.orgColorKey);
      el.primaryModelsBtn.addEventListener("click", () => {
        state.primaryOnly = !state.primaryOnly;
        renderModelToggleGrid(collectModelInfos(state.rows));
        renderAll();
      });
      el.showAllModelsBtn.addEventListener("click", () => {
        state.hiddenModels.clear();
        renderModelToggleGrid(collectModelInfos(state.rows));
        renderAll();
      });
      el.hideAllModelsBtn.addEventListener("click", () => {
        collectModelInfos(state.rows).forEach((info) => state.hiddenModels.add(info.key));
        renderModelToggleGrid(collectModelInfos(state.rows));
        renderAll();
      });
      el.filterModelToggleSearch.addEventListener("input", () => {
        renderModelToggleGrid(collectModelInfos(state.rows));
      });
      if (el.launchBestOnlyToggle) {
        el.launchBestOnlyToggle.addEventListener("change", () => {
          renderLaunchScatter(state.rows);
        });
      }
      let resizeTimer = 0;
      const rerenderLaunchScatter = () => {
        if (!state.rows.length) {
          return;
        }
        window.clearTimeout(resizeTimer);
        resizeTimer = window.setTimeout(() => {
          renderLaunchScatter(state.rows);
        }, 120);
      };
      window.addEventListener("resize", rerenderLaunchScatter);
      if (typeof ResizeObserver === "function" && el.launchScatterSvg) {
        const chartResizeObserver = new ResizeObserver((entries) => {
          const entry = entries && entries[0];
          const nextWidth = Math.round(entry?.contentRect?.width || 0);
          if (!nextWidth || Math.abs(nextWidth - state.launchScatterWidth) < 2) {
            return;
          }
          rerenderLaunchScatter();
        });
        chartResizeObserver.observe(el.launchScatterSvg);
      }
      [1, 2, 3].forEach((judgeIndex) => {
        const toggle = el[`judge${judgeIndex}Toggle`];
        toggle.addEventListener("change", () => {
          syncSelectedJudgesFromUI(judgeIndex);
          state.primaryOnly = false;
          state.chartDrilldown = null;
          state.hiddenModels.clear();
          el.filterModelToggleSearch.value = "";
          el.filterQuery.value = "";
          [...document.querySelectorAll('input[name="scoreFilter"]')].forEach((node) => {
            node.checked = true;
          });
          state.primaryModelKeys = computePrimaryModelKeys(state.rows);
          renderModelToggleGrid(collectModelInfos(state.rows));
          renderAll();
        });
      });
      el.modelToggleGrid.addEventListener("change", (event) => {
        const input = event.target;
        if (!(input instanceof HTMLInputElement) || input.type !== "checkbox") {
          return;
        }
        const key = String(input.getAttribute("data-model-key") || "");
        if (!key) {
          return;
        }
        if (input.checked) {
          state.hiddenModels.delete(key);
        } else {
          state.hiddenModels.add(key);
        }
        renderModelToggleGrid(collectModelInfos(state.rows));
        renderAll();
      });
      el.randomGreenRedBtn.addEventListener("click", () => {
        randomizeQuestionPair("green_red");
      });
      el.randomBestQuestionBtn.addEventListener("click", () => {
        randomizeRankedQuestion("best");
      });
      el.randomWorstQuestionBtn.addEventListener("click", () => {
        randomizeRankedQuestion("worst");
      });
      el.simpleModelBars.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof Element)) {
          return;
        }
        const segment = target.closest(".stack-seg[data-model-key][data-category]");
        if (!segment) {
          return;
        }
        const selectedModelKey = String(segment.getAttribute("data-model-key") || "");
        const selectedCategory = String(segment.getAttribute("data-category") || "");
        if (!selectedModelKey || !CATEGORY_META[selectedCategory]) {
          return;
        }
        const isSameSelection = state.chartDrilldown
          && state.chartDrilldown.modelKey === selectedModelKey
          && state.chartDrilldown.category === selectedCategory;
        state.chartDrilldown = isSameSelection
          ? null
          : { modelKey: selectedModelKey, category: selectedCategory };
        renderAll();
      });
      el.clearChartDrilldownBtn.addEventListener("click", () => {
        state.chartDrilldown = null;
        renderAll();
      });
      const headerCells = el.leaderboardHead.querySelectorAll("th.sortable-th");
      headerCells.forEach((node) => {
        node.addEventListener("click", () => {
          const key = String(node.getAttribute("data-sort-key") || "");
          if (!key) {
            return;
          }
          if (state.leaderboardSort.key === key) {
            state.leaderboardSort.direction =
              state.leaderboardSort.direction === "asc" ? "desc" : "asc";
          } else {
            state.leaderboardSort.key = key;
            state.leaderboardSort.direction =
              key === "model" || key === "org" || key === "reasoning" || key === "launchDate"
                ? "asc"
                : "desc";
          }
          renderAll();
        });
      });
      [
        el.filterOrg,
        el.filterReasoning,
        el.filterTechnique,
        el.filterDomain,
        el.filterQuery,
        el.compareQuestion,
        el.compareQuestionBand,
        el.compareModelA,
        el.compareModelB,
        el.compareViewMode,
      ].forEach((node) => {
        node.addEventListener("change", renderAll);
        if (node.tagName === "INPUT") {
          node.addEventListener("input", renderAll);
        }
      });
    }

    function bootstrap() {
      cacheElements();
      syncSelectedJudgesFromUI();
      buildScoreFilter();
      bindEvents();
      loadDefaultData();
    }

    bootstrap();
  </script>
</body>
</html>
