<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Bullshit Benchmark Explorer</title>
  <style>
    :root {
      --bg: #f7f4ec;
      --panel: #fffefb;
      --ink: #1f2623;
      --muted: #5f6f6a;
      --line: #d6ddd8;
      --teal: #0f766e;
      --teal-soft: #d8f3ef;
      --green: #1f9d55;
      --amber: #d88710;
      --red: #c13d36;
      --deep-red: #8a1f1a;
      --error: #4a5350;
      --shadow: 0 10px 30px rgba(20, 35, 30, 0.08);
      --radius: 14px;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      min-height: 100%;
      color: var(--ink);
      background: radial-gradient(1200px 700px at 100% -50%, #d9efe9 0%, transparent 70%),
        radial-gradient(1000px 600px at -10% 10%, #f6ecd8 0%, transparent 70%),
        var(--bg);
      font-family: "Avenir Next", "Trebuchet MS", "Segoe UI", sans-serif;
    }

    .page {
      width: min(1600px, 96vw);
      margin: 28px auto 48px;
      display: grid;
      gap: 18px;
      animation: fade-up 500ms ease-out both;
    }

    .hero {
      background: linear-gradient(132deg, #113630 0%, #1b5f55 60%, #1d7268 100%);
      color: #f2faf8;
      border-radius: 18px;
      padding: 22px 24px;
      box-shadow: var(--shadow);
    }

    .hero h1 {
      margin: 0;
      font-family: "Rockwell", "Georgia", serif;
      letter-spacing: 0.2px;
      font-size: clamp(1.5rem, 2.5vw, 2.2rem);
    }

    .hero-subtitle {
      margin: 8px 0 0;
      color: #cde9e3;
      max-width: 920px;
    }

    .hero-link {
      border: 1px solid rgba(255, 255, 255, 0.5);
      color: #e6f4f1;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 10px;
      padding: 7px 11px;
      font-size: 0.84rem;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .hero-link:hover {
      background: rgba(255, 255, 255, 0.14);
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px;
      animation: fade-up 550ms ease both;
    }

    .panel h2 {
      margin: 0 0 12px;
      font-size: 1.15rem;
      font-family: "Rockwell", "Georgia", serif;
    }

    .panel h3 {
      margin: 0 0 8px;
      font-size: 1rem;
    }

    .subtle {
      margin: 0;
      color: var(--muted);
      font-size: 0.92rem;
    }

    .grid-2,
    .grid-3,
    .grid-4 {
      display: grid;
      gap: 10px;
    }

    .grid-2 {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .grid-3 {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    .grid-4 {
      grid-template-columns: repeat(4, minmax(0, 1fr));
    }

    label {
      display: grid;
      gap: 5px;
      font-size: 0.87rem;
      color: #394440;
    }

    input[type="text"],
    select,
    textarea {
      border: 1px solid #bcc9c2;
      border-radius: 10px;
      padding: 9px 10px;
      font-size: 0.9rem;
      background: #fff;
      color: var(--ink);
      outline: none;
      width: 100%;
    }

    input[type="text"]:focus,
    select:focus,
    textarea:focus {
      border-color: #5aa495;
      box-shadow: 0 0 0 2px rgba(51, 129, 112, 0.14);
    }

    .button-row {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    button,
    .file-pill {
      border: 1px solid #25584f;
      background: #1d7268;
      color: #fff;
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 0.86rem;
      cursor: pointer;
      transition: transform 140ms ease, box-shadow 140ms ease, background 140ms ease;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    button:hover,
    .file-pill:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 16px rgba(27, 82, 75, 0.2);
      background: #1a665e;
    }

    button.alt {
      background: #fff;
      border-color: #bcc9c2;
      color: #30403a;
      box-shadow: none;
    }

    button.alt:hover {
      background: #f4f8f6;
    }

    .file-pill input {
      display: none;
    }

    .status {
      margin-top: 10px;
      border-radius: 10px;
      padding: 9px 10px;
      background: #eff7f5;
      color: #204740;
      border: 1px solid #c3ddd6;
      font-size: 0.86rem;
      min-height: 38px;
      display: flex;
      align-items: center;
    }

    .status.warn {
      background: #fff6df;
      border-color: #f1d79b;
      color: #744f00;
    }

    .status.error {
      background: #fdecea;
      border-color: #efc2bd;
      color: #7e1f1a;
    }

    .status.good {
      background: #eaf7ee;
      border-color: #bddfc7;
      color: #1c5f34;
    }

    .kpis {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(5, minmax(0, 1fr));
    }

    .kpi {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      background: #fff;
    }

    .kpi .label {
      font-size: 0.79rem;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .kpi .value {
      font-size: 1.35rem;
      font-weight: 700;
      letter-spacing: 0.1px;
    }

    .kpi .hint {
      font-size: 0.77rem;
      color: #667a74;
      margin-top: 2px;
    }

    .kpi.green .value {
      color: var(--green);
    }

    .kpi.amber .value {
      color: var(--amber);
    }

    .kpi.red .value {
      color: var(--red);
    }

    .kpi.error .value {
      color: var(--error);
    }

    .score-filter {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    .score-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      border: 1px solid #cbd7d1;
      padding: 6px 9px;
      font-size: 0.8rem;
      background: #fff;
      color: #32403b;
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }

    .dot.score0 {
      background: var(--red);
    }

    .dot.score1 {
      background: var(--amber);
    }

    .dot.score2 {
      background: var(--green);
    }

    .dot.score3 {
      background: var(--deep-red);
    }

    .dot.error {
      background: var(--error);
    }

    .model-toggle-grid {
      margin-top: 8px;
      border: 1px solid #d2dbd6;
      border-radius: 10px;
      background: #fff;
      padding: 8px;
      max-height: 220px;
      overflow: auto;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
      gap: 6px;
    }

    .model-toggle-item {
      display: flex;
      align-items: center;
      gap: 8px;
      border: 1px solid #d4dfda;
      border-radius: 8px;
      background: #f8fbfa;
      padding: 6px 8px;
      font-size: 0.78rem;
      color: #25453b;
    }

    .model-toggle-item input[type="checkbox"] {
      width: 15px;
      height: 15px;
      margin: 0;
      accent-color: #1d7268;
      cursor: pointer;
      flex: 0 0 auto;
    }

    .model-toggle-item.hidden {
      background: #fbf2f1;
      color: #7a322c;
      border-color: #e2c8c4;
    }

    .model-toggle-item span {
      line-height: 1.2;
    }

    .mix {
      display: grid;
      gap: 8px;
    }

    .mix-track {
      width: 100%;
      height: 20px;
      border-radius: 999px;
      overflow: hidden;
      display: flex;
      border: 1px solid #d1d9d4;
      background: #f3f6f4;
    }

    .mix-seg {
      height: 100%;
      transition: width 280ms ease;
    }

    .mix-seg.score0 {
      background: var(--red);
    }

    .mix-seg.score1 {
      background: var(--amber);
    }

    .mix-seg.score2 {
      background: var(--green);
    }

    .mix-seg.score3 {
      background: var(--deep-red);
    }

    .mix-seg.error {
      background: var(--error);
    }

    .mix-labels {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 0.8rem;
      color: #3b4b45;
    }

    .chart-block {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      background: #fff;
    }

    .chart-head {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }

    .chart-head h2 {
      margin: 0;
    }

    .chart-legend {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
      max-width: 62%;
    }

    .chart-legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      border: 1px solid #cbd7d1;
      padding: 4px 8px;
      font-size: 0.76rem;
      background: #fff;
      color: #32403b;
      white-space: nowrap;
    }

    .bar-list {
      display: grid;
      gap: 8px;
      margin-top: 4px;
      max-height: 460px;
      overflow: auto;
      padding-right: 4px;
    }

    #simpleModelBars {
      max-height: none;
      overflow: visible;
      gap: 6px;
    }

    .bar-row {
      display: grid;
      grid-template-columns: minmax(160px, 260px) 1fr auto;
      gap: 8px;
      align-items: center;
    }

    .bar-row .name {
      font-size: 0.82rem;
      line-height: 1.2;
      color: #22312c;
    }

    .bar {
      background: #f1f5f2;
      height: 16px;
      border-radius: 999px;
      border: 1px solid #d4ddd8;
      overflow: hidden;
      position: relative;
    }

    .bar > span {
      height: 100%;
      display: block;
      background: linear-gradient(90deg, #6dc5b2 0%, #1f9d55 100%);
      transition: width 280ms ease;
    }

    .bar-value {
      font-size: 0.8rem;
      font-weight: 600;
      color: #294137;
      min-width: 54px;
      text-align: right;
    }

    .stack-row {
      display: grid;
      grid-template-columns: 34px minmax(170px, 260px) 1fr;
      grid-template-areas: "rank name bar";
      gap: 8px;
      align-items: center;
    }

    .stack-rank {
      grid-area: rank;
      text-align: right;
      font-size: 0.8rem;
      font-weight: 700;
      color: #5b6c66;
      font-variant-numeric: tabular-nums;
      line-height: 1;
    }

    .stack-row .name {
      grid-area: name;
    }

    .stack-row .stack-track {
      grid-area: bar;
    }

    .stack-track {
      width: 100%;
      height: 20px;
      border-radius: 999px;
      overflow: hidden;
      display: flex;
      border: 1px solid #d1dad5;
      background: #edf3f0;
    }

    .stack-seg {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      white-space: nowrap;
      font-size: 0.68rem;
      font-weight: 700;
      color: #fff;
      letter-spacing: 0.1px;
      cursor: pointer;
      transition: filter 120ms ease, box-shadow 120ms ease;
    }

    .stack-seg:hover {
      filter: brightness(0.95);
    }

    .stack-seg.selected {
      box-shadow: inset 0 0 0 2px rgba(21, 34, 31, 0.55);
    }

    .stack-seg.green {
      background: var(--green);
    }

    .stack-seg.amber {
      background: var(--amber);
    }

    .stack-seg.red {
      background: var(--red);
    }

    .seg-label {
      display: inline-block;
      padding: 0 4px;
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.35);
      line-height: 1;
    }

    .table-wrap {
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #fff;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 980px;
    }

    th,
    td {
      border-bottom: 1px solid #e2e8e4;
      padding: 8px 9px;
      text-align: left;
      vertical-align: top;
      font-size: 0.82rem;
    }

    th {
      position: sticky;
      top: 0;
      z-index: 2;
      background: #f1f6f4;
      font-size: 0.78rem;
      letter-spacing: 0.3px;
      color: #314740;
      text-transform: uppercase;
    }

    th.sortable-th {
      cursor: pointer;
      user-select: none;
    }

    th.sortable-th:hover {
      background: #e8f2ee;
    }

    .sort-ind {
      display: inline-block;
      min-width: 10px;
      margin-left: 4px;
      color: #5e736b;
      font-size: 0.7rem;
      line-height: 1;
      vertical-align: middle;
    }

    tr:hover td {
      background: #f7faf9;
    }

    .model-name {
      font-weight: 600;
      color: #1d2d28;
      line-height: 1.25;
    }

    .mix-cell {
      width: 220px;
    }

    .mini-mix {
      height: 12px;
      border-radius: 999px;
      border: 1px solid #d7e0db;
      background: #f1f4f3;
      overflow: hidden;
      display: flex;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 3px 8px;
      font-size: 0.75rem;
      border: 1px solid transparent;
      font-weight: 600;
      line-height: 1.2;
      white-space: nowrap;
    }

    .pill.score0 {
      color: #7e1f1a;
      background: #fdecea;
      border-color: #efc2bd;
    }

    .pill.score1 {
      color: #744f00;
      background: #fff5dd;
      border-color: #efd89f;
    }

    .pill.score2 {
      color: #175f33;
      background: #e6f6ec;
      border-color: #bee2c8;
    }

    .pill.score3 {
      color: #591512;
      background: #f9e3e1;
      border-color: #e7b4af;
    }

    .pill.error {
      color: #27312e;
      background: #ecefee;
      border-color: #cdd4d1;
    }

    .run-meta {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 0.8rem;
      color: #334741;
      margin-top: 8px;
    }

    .run-meta span {
      background: #f1f6f4;
      border: 1px solid #d0dbd6;
      border-radius: 8px;
      padding: 4px 8px;
    }

    .compare-controls {
      display: grid;
      gap: 10px;
      grid-template-columns: 1.2fr 1fr 1fr 0.85fr 1fr;
      align-items: end;
      margin-bottom: 10px;
    }

    .compare-actions {
      margin-top: 8px;
      margin-bottom: 14px;
    }

    button.alt.btn-best {
      background: #eaf7ee;
      border-color: #a7d8b6;
      color: #185232;
    }

    button.alt.btn-best:hover {
      background: #ddf2e4;
    }

    button.alt.btn-worst {
      background: #fdecea;
      border-color: #e7bdb8;
      color: #7f2a23;
    }

    button.alt.btn-worst:hover {
      background: #fbe0dd;
    }

    .question-context {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #fff;
      padding: 10px;
      margin-bottom: 10px;
      display: grid;
      gap: 8px;
    }

    .question-context .question {
      margin: 0;
      font-size: 1.2rem;
      font-weight: 700;
      line-height: 1.4;
      color: #1f2e29;
    }

    .ab-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      margin-bottom: 12px;
    }

    .all-responses-grid {
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    }

    .hidden-block {
      display: none !important;
    }

    .response-card {
      border: 2px solid #cfd9d4;
      border-radius: 12px;
      padding: 10px;
      background: #fff;
      display: grid;
      gap: 8px;
      min-height: 260px;
    }

    .response-card.score0 {
      border-color: #e4a6a2;
      background: linear-gradient(180deg, #fff7f6 0%, #fff 24%);
    }

    .response-card.score1 {
      border-color: #e7cb89;
      background: linear-gradient(180deg, #fffaf0 0%, #fff 24%);
    }

    .response-card.score2 {
      border-color: #9fd2ae;
      background: linear-gradient(180deg, #f2fbf5 0%, #fff 24%);
    }

    .response-card.score3 {
      border-color: #df9b95;
      background: linear-gradient(180deg, #fff5f3 0%, #fff 24%);
    }

    .response-card.error {
      border-color: #b9c4bf;
      background: linear-gradient(180deg, #f3f5f4 0%, #fff 24%);
    }

    .response-head {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: start;
    }

    .response-head .title {
      margin: 0;
      font-size: 0.88rem;
      color: #1d2d28;
      line-height: 1.25;
    }

    .response-text {
      margin: 0;
      white-space: pre-wrap;
      line-height: 1.44;
      font-size: 0.82rem;
      color: #233530;
      max-height: 360px;
      overflow: auto;
      border: 1px solid #dbe4df;
      border-radius: 9px;
      background: #fdfefd;
      padding: 8px;
    }

    .small-note {
      margin-top: 6px;
      color: #5b6f68;
      font-size: 0.8rem;
    }

    .drilldown-head {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
    }

    .drilldown-head h2 {
      margin: 0;
    }

    .drilldown-head .small-note {
      margin: 4px 0 0;
    }

    .drilldown-list {
      margin-top: 10px;
      display: grid;
      gap: 10px;
    }

    .drilldown-item {
      border: 1px solid #d6e0db;
      border-radius: 10px;
      background: #fff;
      padding: 9px;
      display: grid;
      gap: 7px;
    }

    .drilldown-item .meta {
      font-size: 0.78rem;
      color: #506660;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    .drilldown-item .question {
      margin: 0;
      font-size: 0.98rem;
      line-height: 1.36;
      color: #1b2a25;
      font-weight: 650;
    }

    .drilldown-item .response {
      margin: 0;
      white-space: pre-wrap;
      font-size: 0.82rem;
      line-height: 1.4;
      color: #223530;
      border: 1px solid #dbe4df;
      border-radius: 8px;
      background: #fcfdfd;
      padding: 8px;
    }

    .filters-panel {
      padding: 12px 14px;
    }

    .filters-panel h2 {
      margin-bottom: 8px;
    }

    .filters-grid {
      grid-template-columns: minmax(220px, 1.25fr) repeat(4, minmax(130px, 1fr));
      gap: 8px;
    }

    .filters-panel label {
      gap: 3px;
      font-size: 0.82rem;
    }

    .filters-panel input[type="text"],
    .filters-panel select {
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 0.84rem;
    }

    .filters-panel .button-row {
      margin-top: 6px;
      gap: 6px;
    }

    .filters-panel button {
      border-radius: 8px;
      padding: 5px 9px;
      font-size: 0.78rem;
    }

    .filters-panel .score-filter {
      margin-top: 0;
      gap: 6px;
    }

    .filters-panel .score-chip {
      padding: 4px 8px;
      font-size: 0.74rem;
    }

    .filters-panel .small-note {
      font-size: 0.76rem;
      margin-top: 4px;
    }

    .filter-meta-row {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
    }

    .filter-meta-row .small-note {
      margin: 0;
    }

    .judge-filter-row {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }

    .judge-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid #cfdbd5;
      border-radius: 999px;
      background: #f8fbfa;
      color: #2c433c;
      padding: 4px 8px;
      font-size: 0.74rem;
      line-height: 1.2;
    }

    .judge-chip input[type="checkbox"] {
      margin: 0;
      width: 13px;
      height: 13px;
      accent-color: #1d7268;
      cursor: pointer;
      flex: 0 0 auto;
    }

    .model-visibility-block {
      margin-top: 8px;
      border: 1px solid #d2dbd6;
      border-radius: 10px;
      background: #fbfcfb;
      padding: 6px 8px 8px;
    }

    .model-visibility-block summary {
      list-style: none;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.82rem;
      font-weight: 600;
      color: #32443e;
      user-select: none;
    }

    .model-visibility-block summary::-webkit-details-marker {
      display: none;
    }

    .model-visibility-block summary::before {
      content: "â–¸";
      font-size: 0.8rem;
      color: #5a736c;
      transition: transform 120ms ease;
    }

    .model-visibility-block[open] summary::before {
      transform: rotate(90deg);
    }

    .model-visibility-inner {
      margin-top: 6px;
      display: grid;
      gap: 6px;
    }

    .filters-panel .model-toggle-grid {
      margin-top: 0;
      max-height: 150px;
      padding: 6px;
      gap: 4px;
      grid-template-columns: repeat(auto-fill, minmax(210px, 1fr));
    }

    .filters-panel .model-toggle-item {
      border-radius: 7px;
      padding: 4px 6px;
      gap: 6px;
      font-size: 0.74rem;
    }

    .filters-panel .model-toggle-item input[type="checkbox"] {
      width: 13px;
      height: 13px;
    }

    @media (max-width: 1240px) {
      .kpis {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      .grid-4 {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .filters-grid {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    @media (max-width: 900px) {
      .grid-2,
      .grid-3,
      .grid-4,
      .compare-controls,
      .ab-grid,
      .kpis {
        grid-template-columns: 1fr;
      }

      .bar-row {
        grid-template-columns: 1fr;
      }

      .bar-value {
        text-align: left;
      }

      .stack-row {
        grid-template-columns: 34px 1fr;
        grid-template-areas:
          "rank name"
          "bar bar";
      }

      .filters-grid {
        grid-template-columns: 1fr;
      }

      .filter-meta-row {
        align-items: flex-start;
      }

      .chart-head {
        flex-direction: column;
      }

      .chart-legend {
        max-width: 100%;
        justify-content: flex-start;
      }

    }

    @keyframes fade-up {
      from {
        opacity: 0;
        transform: translateY(12px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header class="hero">
      <h1>Bullshit Benchmark - Models Answering Nonsense Questions</h1>
      <p class="hero-subtitle">
        This benchmark measures whether models detect broken premises, call out the nonsense directly, and avoid confidently
        continuing with invalid assumptions.
      </p>
    </header>

    <section class="panel filters-panel">
      <h2>Filters</h2>
      <div class="grid-3 filters-grid">
        <label>
          <span>Search</span>
          <input id="filterQuery" type="text" placeholder="Model, question id, prompt text...">
        </label>
        <label>
          <span>Org</span>
          <select id="filterOrg"></select>
        </label>
        <label>
          <span>Reasoning</span>
          <select id="filterReasoning"></select>
        </label>
        <label>
          <span>Technique</span>
          <select id="filterTechnique"></select>
        </label>
        <label>
          <span>Domain</span>
          <select id="filterDomain"></select>
        </label>
      </div>
      <div class="judge-filter-row">
        <span class="small-note">Judges (tick to include):</span>
        <label class="judge-chip">
          <input type="checkbox" id="judge1Toggle" checked>
          <span id="judge1Label">Loading...</span>
        </label>
        <label class="judge-chip">
          <input type="checkbox" id="judge2Toggle" checked>
          <span id="judge2Label">Loading...</span>
        </label>
        <label class="judge-chip">
          <input type="checkbox" id="judge3Toggle" checked>
          <span id="judge3Label">Loading...</span>
        </label>
      </div>
      <div class="filter-meta-row">
        <span class="small-note">Outcome filter:</span>
        <div class="score-filter" id="scoreFilter"></div>
      </div>
      <details class="model-visibility-block">
        <summary>Model visibility and quick actions</summary>
        <div class="model-visibility-inner">
        <label>
          <span>Search models</span>
          <input id="filterModelToggleSearch" type="text" placeholder="Search model names...">
        </label>
        <div class="button-row">
          <button id="primaryModelsBtn" class="alt" type="button">Primary Models: Off</button>
          <button id="showAllModelsBtn" class="alt" type="button">Show All Models</button>
          <button id="hideAllModelsBtn" class="alt" type="button">Hide All Models</button>
          <button id="clearFiltersBtn" class="alt" type="button">Reset All Filters</button>
        </div>
        <div id="modelToggleGrid" class="model-toggle-grid"></div>
        <p id="modelToggleNote" class="small-note"></p>
        </div>
      </details>
      <p class="small-note" id="dataState"></p>
    </section>

    <section class="panel">
      <div class="chart-head">
        <h2>Bullshit Benchmark - Models Answering Nonsense Questions</h2>
        <div class="chart-legend" aria-label="Model detection legend">
          <span class="chart-legend-item"><span class="dot score2"></span>Clear Pushback</span>
          <span class="chart-legend-item"><span class="dot score1"></span>Partial Challenge</span>
          <span class="chart-legend-item"><span class="dot score0"></span>Accepted Nonsense</span>
        </div>
      </div>
      <div class="bar-list" id="simpleModelBars"></div>
    </section>

    <section class="panel hidden-block" id="chartDrilldownPanel">
      <div class="drilldown-head">
        <div>
          <h2 id="chartDrilldownTitle">Selected Segment</h2>
          <p class="small-note" id="chartDrilldownMeta"></p>
        </div>
        <button type="button" id="clearChartDrilldownBtn" class="alt">Clear Selection</button>
      </div>
      <div id="chartDrilldownBody" class="drilldown-list"></div>
    </section>

    <section class="panel">
      <h2>Model Leaderboard</h2>
      <div class="table-wrap">
        <table>
          <thead id="leaderboardHead">
            <tr>
              <th class="sortable-th" data-sort-key="rank">Rank <span class="sort-ind" data-sort-ind="rank"></span></th>
              <th class="sortable-th" data-sort-key="model">Model <span class="sort-ind" data-sort-ind="model"></span></th>
              <th class="sortable-th" data-sort-key="org">Org <span class="sort-ind" data-sort-ind="org"></span></th>
              <th class="sortable-th" data-sort-key="reasoning">Reasoning <span class="sort-ind" data-sort-ind="reasoning"></span></th>
              <th class="sortable-th" data-sort-key="greenRate">Green % <span class="sort-ind" data-sort-ind="greenRate"></span></th>
              <th class="sortable-th" data-sort-key="amberRate">Amber % <span class="sort-ind" data-sort-ind="amberRate"></span></th>
              <th class="sortable-th" data-sort-key="redRate">Red % <span class="sort-ind" data-sort-ind="redRate"></span></th>
              <th class="sortable-th" data-sort-key="errorRate">Error % <span class="sort-ind" data-sort-ind="errorRate"></span></th>
              <th>Mix (Green/Amber/Red/Error)</th>
              <th class="sortable-th" data-sort-key="rows">Rows <span class="sort-ind" data-sort-ind="rows"></span></th>
            </tr>
          </thead>
          <tbody id="leaderboardBody"></tbody>
        </table>
      </div>
    </section>

    <section class="panel">
      <h2>Response Viewer</h2>
      <div class="compare-controls">
        <label>
          <span>Question</span>
          <select id="compareQuestion"></select>
        </label>
        <label>
          <span>Model A</span>
          <select id="compareModelA"></select>
        </label>
        <label>
          <span>Model B</span>
          <select id="compareModelB"></select>
        </label>
        <label>
          <span>View</span>
          <select id="compareViewMode">
            <option value="pair">Compare 2</option>
            <option value="all">Show all</option>
          </select>
        </label>
        <label>
          <span>Question % Correct</span>
          <select id="compareQuestionBand">
            <option value="all">All</option>
            <option value="80_100">80-100%</option>
            <option value="60_80">60-79%</option>
            <option value="40_60">40-59%</option>
            <option value="20_40">20-39%</option>
            <option value="0_20">0-19%</option>
          </select>
        </label>
      </div>
      <div class="button-row compare-actions">
        <button type="button" id="randomPairBtn" class="alt">Random Pair</button>
        <button type="button" id="randomGreenRedBtn" class="alt">Random Green vs Red</button>
        <button type="button" id="randomBestQuestionBtn" class="alt btn-best">Random Best Question</button>
        <button type="button" id="randomWorstQuestionBtn" class="alt btn-worst">Random Worst Question</button>
      </div>
      <div id="questionContext" class="question-context"></div>
      <div id="pairGrid" class="ab-grid">
        <div id="modelACard"></div>
        <div id="modelBCard"></div>
      </div>
      <div id="allResponsesGrid" class="ab-grid all-responses-grid hidden-block"></div>
    </section>
  </div>

  <script>
    const DEFAULT_PATHS = {
      responses: "data/latest/responses.jsonl",
      collectionStats: "data/latest/collection_stats.json",
      panelSummary: "data/latest/panel_summary.json",
      aggregateSummary: "data/latest/aggregate_summary.json",
      aggregateRows: "data/latest/aggregate.jsonl",
    };

    const CATEGORY_META = {
      green: { label: "Green", colorClass: "score2", short: "Green" },
      amber: { label: "Amber", colorClass: "score1", short: "Amber" },
      red: { label: "Red", colorClass: "score0", short: "Red" },
      error: { label: "Error", colorClass: "error", short: "Error" },
    };
    const CATEGORY_ORDER = ["green", "amber", "red", "error"];
    const TECHNIQUE_LABELS = {
      authoritative_framing_of_nothing: "Confident Nonsense Framing",
      causal_chimera: "Fake Cause-and-Effect Mix",
      cross_domain_concept_stitching: "Cross-Domain Concept Stitching",
      false_granularity: "Fake Precision",
      inverted_nonexistent_dependency: "Invented Dependency Reversal",
      misapplied_mechanism: "Misapplied Mechanism",
      plausible_nonexistent_framework: "Plausible but Fake Framework",
      reified_metaphor: "Literalized Metaphor",
      temporal_category_error: "Time/Category Mix-up",
      wrong_unit_of_analysis: "Wrong Unit of Analysis",
    };

    const state = {
      responses: [],
      collectionStats: null,
      panelSummary: null,
      aggregateSummary: null,
      aggregateRows: [],
      rows: [],
      filteredRows: [],
      bySampleId: new Map(),
      questionRows: [],
      hiddenModels: new Set(),
      primaryOnly: false,
      primaryModelKeys: new Set(),
      selectedJudges: new Set([1, 2, 3]),
      chartDrilldown: null,
      leaderboardSort: {
        key: "greenRate",
        direction: "desc",
      },
    };

    const el = {};

    function cacheElements() {
      el.dataState = document.getElementById("dataState");
      el.simpleModelBars = document.getElementById("simpleModelBars");
      el.leaderboardHead = document.getElementById("leaderboardHead");
      el.leaderboardBody = document.getElementById("leaderboardBody");
      el.chartDrilldownPanel = document.getElementById("chartDrilldownPanel");
      el.chartDrilldownTitle = document.getElementById("chartDrilldownTitle");
      el.chartDrilldownMeta = document.getElementById("chartDrilldownMeta");
      el.chartDrilldownBody = document.getElementById("chartDrilldownBody");
      el.clearChartDrilldownBtn = document.getElementById("clearChartDrilldownBtn");
      el.scoreFilter = document.getElementById("scoreFilter");
      el.clearFiltersBtn = document.getElementById("clearFiltersBtn");
      el.filterOrg = document.getElementById("filterOrg");
      el.filterModelToggleSearch = document.getElementById("filterModelToggleSearch");
      el.modelToggleGrid = document.getElementById("modelToggleGrid");
      el.modelToggleNote = document.getElementById("modelToggleNote");
      el.primaryModelsBtn = document.getElementById("primaryModelsBtn");
      el.showAllModelsBtn = document.getElementById("showAllModelsBtn");
      el.hideAllModelsBtn = document.getElementById("hideAllModelsBtn");
      el.filterReasoning = document.getElementById("filterReasoning");
      el.filterTechnique = document.getElementById("filterTechnique");
      el.filterDomain = document.getElementById("filterDomain");
      el.judge1Toggle = document.getElementById("judge1Toggle");
      el.judge2Toggle = document.getElementById("judge2Toggle");
      el.judge3Toggle = document.getElementById("judge3Toggle");
      el.judge1Label = document.getElementById("judge1Label");
      el.judge2Label = document.getElementById("judge2Label");
      el.judge3Label = document.getElementById("judge3Label");
      el.filterQuery = document.getElementById("filterQuery");
      el.compareQuestion = document.getElementById("compareQuestion");
      el.compareModelA = document.getElementById("compareModelA");
      el.compareModelB = document.getElementById("compareModelB");
      el.compareViewMode = document.getElementById("compareViewMode");
      el.compareQuestionBand = document.getElementById("compareQuestionBand");
      el.randomPairBtn = document.getElementById("randomPairBtn");
      el.randomGreenRedBtn = document.getElementById("randomGreenRedBtn");
      el.randomBestQuestionBtn = document.getElementById("randomBestQuestionBtn");
      el.randomWorstQuestionBtn = document.getElementById("randomWorstQuestionBtn");
      el.questionContext = document.getElementById("questionContext");
      el.pairGrid = document.getElementById("pairGrid");
      el.allResponsesGrid = document.getElementById("allResponsesGrid");
      el.modelACard = document.getElementById("modelACard");
      el.modelBCard = document.getElementById("modelBCard");
    }

    function escapeHtml(value) {
      return String(value ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function defaultPathPrefix() {
      const pathname = window.location.pathname || "";
      return pathname.includes("/viewer/") ? "../" : "";
    }

    function resolvedDefaultPaths() {
      const prefix = defaultPathPrefix();
      return {
        responses: `${prefix}${DEFAULT_PATHS.responses}`,
        collectionStats: `${prefix}${DEFAULT_PATHS.collectionStats}`,
        panelSummary: `${prefix}${DEFAULT_PATHS.panelSummary}`,
        aggregateSummary: `${prefix}${DEFAULT_PATHS.aggregateSummary}`,
        aggregateRows: `${prefix}${DEFAULT_PATHS.aggregateRows}`,
      };
    }

    function setDataState(message) {
      if (el.dataState) {
        el.dataState.textContent = message;
      }
    }

    function parseJsonlStrict(text, filename) {
      const out = [];
      const lines = text.split(/\r?\n/);
      for (let i = 0; i < lines.length; i += 1) {
        const line = lines[i].trim();
        if (!line) {
          continue;
        }
        try {
          out.push(JSON.parse(line));
        } catch (error) {
          throw new Error(`${filename}: invalid JSONL at line ${i + 1}`);
        }
      }
      return out;
    }

    function parseJsonlTolerant(text, filename) {
      const out = [];
      let buffer = "";
      let depth = 0;
      let inString = false;
      let escaping = false;
      let lineNo = 1;
      let recordStartLine = 1;

      for (let i = 0; i < text.length; i += 1) {
        const ch = text[i];

        if (depth === 0) {
          if (!/\S/.test(ch)) {
            if (ch === "\n") {
              lineNo += 1;
            }
            continue;
          }
          if (ch !== "{") {
            throw new Error(`${filename}: invalid JSONL near line ${lineNo}`);
          }
          buffer = "{";
          depth = 1;
          inString = false;
          escaping = false;
          recordStartLine = lineNo;
          continue;
        }

        if (inString) {
          if (escaping) {
            buffer += ch;
            escaping = false;
          } else if (ch === "\\") {
            buffer += ch;
            escaping = true;
          } else if (ch === "\"") {
            buffer += ch;
            inString = false;
          } else if (ch === "\n") {
            buffer += "\\n";
            lineNo += 1;
            continue;
          } else if (ch === "\r") {
            buffer += "\\r";
          } else {
            buffer += ch;
          }
        } else {
          buffer += ch;
          if (ch === "\"") {
            inString = true;
          } else if (ch === "{") {
            depth += 1;
          } else if (ch === "}") {
            depth -= 1;
            if (depth === 0) {
              try {
                out.push(JSON.parse(buffer));
              } catch (_error) {
                throw new Error(`${filename}: invalid JSON object starting at line ${recordStartLine}`);
              }
              buffer = "";
            }
          }
        }

        if (ch === "\n") {
          lineNo += 1;
        }
      }

      if (depth !== 0 || inString) {
        throw new Error(`${filename}: unterminated JSON object near line ${recordStartLine}`);
      }

      return out;
    }

    function parseJsonl(text, filename) {
      try {
        return parseJsonlStrict(text, filename);
      } catch (strictError) {
        try {
          return parseJsonlTolerant(text, filename);
        } catch (_fallbackError) {
          throw strictError;
        }
      }
    }

    function fetchCandidates(path) {
      const input = String(path || "").trim();
      const candidates = [];
      const push = (candidate) => {
        if (candidate && !candidates.includes(candidate)) {
          candidates.push(candidate);
        }
      };

      if (!input) {
        return candidates;
      }

      if (/^https?:\/\//i.test(input)) {
        push(input);
        return candidates;
      }

      push(input);
      if (input.startsWith("./")) {
        push(input.slice(2));
      }
      if (!input.startsWith("/")) {
        push(`/${input}`);
      } else {
        push(input.slice(1));
      }
      if (!input.startsWith("../")) {
        push(`../${input}`);
      } else {
        push(input.replace(/^\.\.\//, ""));
      }
      return candidates;
    }

    function embeddedFileStore() {
      const store = window.__BULLSHIT_BENCHMARK_EMBEDDED_FILES__;
      return store && typeof store === "object" ? store : null;
    }

    function embeddedTextForPath(path) {
      const store = embeddedFileStore();
      if (!store) {
        return null;
      }

      const candidates = fetchCandidates(path);
      for (const candidate of candidates) {
        const raw = String(candidate || "").trim();
        if (!raw) {
          continue;
        }
        const noDotPrefix = raw.replace(/^\.\//, "");
        const noLeadingSlash = noDotPrefix.replace(/^\//, "");
        const noViewerPrefix = noLeadingSlash.replace(/^viewer\//, "");
        const keys = [
          raw,
          noDotPrefix,
          noLeadingSlash,
          noViewerPrefix,
          `viewer/${noViewerPrefix}`,
        ];
        for (const key of keys) {
          if (Object.prototype.hasOwnProperty.call(store, key)) {
            return String(store[key]);
          }
        }
      }
      return null;
    }

    async function fetchText(path) {
      const candidates = fetchCandidates(path);
      if (!candidates.length) {
        throw new Error("missing file path");
      }
      const embedded = embeddedTextForPath(path);
      if (embedded !== null) {
        return embedded;
      }
      let lastError = `${path} (unresolved)`;

      for (const candidate of candidates) {
        try {
          const response = await fetch(candidate, { cache: "no-store" });
          if (response.ok) {
            return response.text();
          }
          lastError = `${candidate} (${response.status})`;
        } catch (error) {
          lastError = `${candidate} (${error.message})`;
        }
      }
      throw new Error(lastError);
    }

    function titleCaseWord(token) {
      if (!token) {
        return "";
      }
      const lower = String(token).toLowerCase();
      const alias = {
        gpt: "GPT",
        oss: "OSS",
        ai: "AI",
        it: "IT",
      };
      if (alias[lower]) {
        return alias[lower];
      }
      if (/^\d+[a-z]+$/i.test(token)) {
        return lower;
      }
      if (/^[a-z]\d+$/i.test(token)) {
        return lower;
      }
      return token.charAt(0).toUpperCase() + token.slice(1);
    }

    function rawModelName(row) {
      if (row && row.model_name) {
        return String(row.model_name);
      }
      const model = String((row && row.model) || "");
      const slashIdx = model.indexOf("/");
      const tail = slashIdx >= 0 ? model.slice(slashIdx + 1) : model;
      const atIdx = tail.indexOf("@");
      return atIdx >= 0 ? tail.slice(0, atIdx) : tail;
    }

    function normalizeReasoningLevel(value) {
      const raw = String(value || "none").toLowerCase();
      return raw === "default" ? "none" : raw;
    }

    function reasoningFilterLevel(value) {
      const normalized = normalizeReasoningLevel(value);
      return normalized === "xhigh" ? "high" : normalized;
    }

    function prettyModelName(row) {
      const raw = rawModelName(row).replace(/_/g, "-");
      const tokens = raw.split("-").filter(Boolean);
      if (!tokens.length) {
        return "Model";
      }
      const mapped = tokens.map((token) => titleCaseWord(token));
      if (mapped[0] === "GPT" && tokens[1] && /^\d/.test(tokens[1])) {
        mapped.splice(0, 2, `GPT-${tokens[1]}`);
      }
      const reasoning = normalizeReasoningLevel(row && row.model_reasoning_level);
      const suffix = reasoning && reasoning !== "none"
        ? ` (${reasoning.charAt(0).toUpperCase()}${reasoning.slice(1)})`
        : "";
      return `${mapped.join(" ")}${suffix}`;
    }

    function modelKey(row) {
      if (!row) {
        return "";
      }
      if (row.model) {
        return String(row.model);
      }
      const org = String(row.model_org || "unknown");
      const name = String(rawModelName(row) || "model");
      const reasoning = String(row.model_reasoning_level || "none");
      return `${org}/${name}@reasoning=${reasoning}`;
    }

    function baseModelGroupKey(row) {
      const org = String((row && row.model_org) || "unknown");
      const name = rawModelName(row) || "model";
      return `${org}/${name}`;
    }

    function reasoningPreference(level) {
      const normalized = normalizeReasoningLevel(level);
      if (normalized === "none") {
        return 3;
      }
      if (normalized === "high") {
        return 2;
      }
      if (normalized === "low") {
        return 1;
      }
      return 0;
    }

    function judgeScoreFromRow(row, judgeIndex) {
      if (!row) {
        return null;
      }
      const statusKey = `judge_${judgeIndex}_status`;
      const scoreKeyName = `judge_${judgeIndex}_score`;
      const status = String(row[statusKey] || "");
      if (status && status !== "ok") {
        return null;
      }
      const score = Number(row[scoreKeyName]);
      if (Number.isNaN(score) || ![0, 1, 2, 3].includes(score)) {
        return null;
      }
      return score;
    }

    function selectedJudgeIds() {
      return [...state.selectedJudges].sort((a, b) => a - b);
    }

    function syncSelectedJudgesFromUI(changedJudge = null) {
      const selected = new Set();
      if (el.judge1Toggle.checked && !el.judge1Toggle.disabled) {
        selected.add(1);
      }
      if (el.judge2Toggle.checked && !el.judge2Toggle.disabled) {
        selected.add(2);
      }
      if (el.judge3Toggle.checked && !el.judge3Toggle.disabled) {
        selected.add(3);
      }

      if (!selected.size) {
        const fallback = changedJudge && !el[`judge${changedJudge}Toggle`].disabled
          ? changedJudge
          : [1, 2, 3].find((judgeIndex) => {
            const toggle = el[`judge${judgeIndex}Toggle`];
            return toggle && !toggle.disabled;
          });
        if (fallback) {
          el[`judge${fallback}Toggle`].checked = true;
          selected.add(fallback);
        }
      }
      state.selectedJudges = selected;
    }

    function judgeModelName(judgeIndex) {
      const field = `judge_${judgeIndex}_model`;
      for (const row of state.rows) {
        const value = row && row[field];
        if (value) {
          return String(value);
        }
      }
      return "";
    }

    function refreshJudgeFilterLabels() {
      [1, 2, 3].forEach((judgeIndex) => {
        const toggle = el[`judge${judgeIndex}Toggle`];
        const label = el[`judge${judgeIndex}Label`];
        if (!toggle || !label) {
          return;
        }
        const model = judgeModelName(judgeIndex);
        if (model) {
          label.textContent = displayModel({ model });
          toggle.disabled = false;
        } else {
          label.textContent = "Unavailable";
          toggle.checked = false;
          toggle.disabled = true;
        }
      });
      syncSelectedJudgesFromUI();
    }

    function categoryFromScore(score) {
      if (score === 2 || score === "2") {
        return "green";
      }
      if (score === 1 || score === "1") {
        return "amber";
      }
      if (score === 0 || score === "0" || score === 3 || score === "3") {
        return "red";
      }
      return "error";
    }

    function categoryKey(row) {
      const chosenJudges = selectedJudgeIds();
      if (!chosenJudges.length) {
        return "error";
      }
      const categories = chosenJudges
        .map((judgeIndex) => judgeScoreFromRow(row, judgeIndex))
        .filter((score) => score !== null)
        .map((score) => categoryFromScore(score));

      if (!categories.length) {
        return "error";
      }
      if (categories.length === 1) {
        return categories[0];
      }

      const counts = { green: 0, amber: 0, red: 0 };
      categories.forEach((category) => {
        if (Object.prototype.hasOwnProperty.call(counts, category)) {
          counts[category] += 1;
        }
      });
      const maxCount = Math.max(counts.green, counts.amber, counts.red);
      const winners = Object.entries(counts)
        .filter(([, count]) => count === maxCount && count > 0)
        .map(([category]) => category);

      if (winners.length === 1) {
        return winners[0];
      }
      return "amber";
    }

    function categoryRank(category) {
      if (category === "green") {
        return 3;
      }
      if (category === "amber") {
        return 2;
      }
      if (category === "red") {
        return 1;
      }
      return 0;
    }

    function displayModel(row) {
      if (!row) {
        return "N/A";
      }
      return prettyModelName(row);
    }

    function normalizeRows(aggregateRows, responses) {
      if (!aggregateRows.length) {
        return responses.map((row) => ({
          ...row,
          consensus_score: null,
          status: row.status || "ok",
          judge_1_score: null,
          judge_2_score: null,
          judge_3_score: null,
          judge_1_justification: "",
          judge_2_justification: "",
          judge_3_justification: "",
        }));
      }

      const responseMap = new Map();
      responses.forEach((r) => {
        if (r.sample_id) {
          responseMap.set(r.sample_id, r);
        }
      });

      return aggregateRows.map((row) => {
        const source = responseMap.get(row.sample_id) || {};
        return {
          ...source,
          ...row,
          response_text: row.response_text || source.response_text || "",
          question: row.question || source.question || "",
          nonsensical_element: row.nonsensical_element || source.nonsensical_element || "",
        };
      });
    }

    function uniqSorted(values) {
      return [...new Set(values.filter((v) => v !== undefined && v !== null && String(v).length > 0))]
        .map(String)
        .sort((a, b) => a.localeCompare(b));
    }

    function displayTechnique(value) {
      const raw = String(value || "unknown");
      if (TECHNIQUE_LABELS[raw]) {
        return TECHNIQUE_LABELS[raw];
      }
      return raw
        .split("_")
        .filter(Boolean)
        .map((token) => titleCaseWord(token))
        .join(" ");
    }

    function fillSelect(selectEl, values, keep = "all", labelFormatter = (value) => value) {
      const previous = selectEl.value;
      const options = [`<option value="all">All</option>`];
      values.forEach((value) => {
        options.push(
          `<option value="${escapeHtml(value)}">${escapeHtml(labelFormatter(value))}</option>`,
        );
      });
      selectEl.innerHTML = options.join("");
      if (previous && values.includes(previous)) {
        selectEl.value = previous;
      } else {
        selectEl.value = keep;
      }
    }

    function collectModelInfos(rows) {
      const map = new Map();
      rows.forEach((row) => {
        const key = modelKey(row);
        if (!key || map.has(key)) {
          return;
        }
        map.set(key, { key, label: displayModel(row) });
      });
      return [...map.values()].sort((a, b) => a.label.localeCompare(b.label));
    }

    function computePrimaryModelKeys(rows) {
      const NON_REASONING_MIN_COVERAGE_RATIO = 0.85;
      const NON_REASONING_MAX_GREEN_GAP = 0.03;
      const groups = new Map();
      rows.forEach((row) => {
        const groupKey = baseModelGroupKey(row);
        const variantKey = modelKey(row);
        if (!groups.has(groupKey)) {
          groups.set(groupKey, new Map());
        }
        const variants = groups.get(groupKey);
        if (!variants.has(variantKey)) {
          variants.set(variantKey, {
            key: variantKey,
            scoredRows: 0,
            totalRows: 0,
            reasoningPref: reasoningPreference(row.model_reasoning_level),
            isNonReasoning: normalizeReasoningLevel(row.model_reasoning_level) === "none",
            greenRows: 0,
            redRows: 0,
          });
        }
        const variant = variants.get(variantKey);
        variant.totalRows += 1;
        const category = categoryKey(row);
        if (category === "green") {
          variant.greenRows += 1;
        } else if (category === "red") {
          variant.redRows += 1;
        }
        if (category !== "error") {
          variant.scoredRows += 1;
        }
      });

      const winners = new Set();
      groups.forEach((variants) => {
        const list = [...variants.values()];
        list.forEach((variant) => {
          const denom = variant.scoredRows || 1;
          variant.greenRate = variant.greenRows / denom;
          variant.redRate = variant.redRows / denom;
        });

        const bestCoverage = list.reduce((maxValue, variant) => Math.max(maxValue, variant.scoredRows), 0);
        const bestGreenRate = list.reduce((maxValue, variant) => Math.max(maxValue, variant.greenRate), 0);

        let preferredNonReasoning = null;
        const nonReasoningVariants = list
          .filter((variant) => variant.isNonReasoning)
          .sort((a, b) => {
            if (b.scoredRows !== a.scoredRows) {
              return b.scoredRows - a.scoredRows;
            }
            if (b.greenRate !== a.greenRate) {
              return b.greenRate - a.greenRate;
            }
            if (a.redRate !== b.redRate) {
              return a.redRate - b.redRate;
            }
            if (b.totalRows !== a.totalRows) {
              return b.totalRows - a.totalRows;
            }
            return a.key.localeCompare(b.key);
          });

        if (nonReasoningVariants[0]) {
          const candidate = nonReasoningVariants[0];
          const coverageRatio = bestCoverage === 0 ? 1 : candidate.scoredRows / bestCoverage;
          const greenGap = bestGreenRate - candidate.greenRate;
          if (coverageRatio >= NON_REASONING_MIN_COVERAGE_RATIO && greenGap <= NON_REASONING_MAX_GREEN_GAP) {
            preferredNonReasoning = candidate;
          }
        }

        if (preferredNonReasoning) {
          winners.add(preferredNonReasoning.key);
          return;
        }

        list.sort((a, b) => {
          if (b.scoredRows !== a.scoredRows) {
            return b.scoredRows - a.scoredRows;
          }
          if (b.greenRate !== a.greenRate) {
            return b.greenRate - a.greenRate;
          }
          if (a.redRate !== b.redRate) {
            return a.redRate - b.redRate;
          }
          if (b.totalRows !== a.totalRows) {
            return b.totalRows - a.totalRows;
          }
          if (b.reasoningPref !== a.reasoningPref) {
            return b.reasoningPref - a.reasoningPref;
          }
          return a.key.localeCompare(b.key);
        });
        if (list[0]) {
          winners.add(list[0].key);
        }
      });
      return winners;
    }

    function updatePrimaryModelsButton() {
      const active = state.primaryOnly;
      const count = state.primaryModelKeys.size;
      el.primaryModelsBtn.textContent = active
        ? `Primary Models: On (${count})`
        : "Primary Models: Off";
      el.primaryModelsBtn.classList.toggle("active", active);
    }

    function renderModelToggleGrid(modelInfos) {
      const query = (el.filterModelToggleSearch.value || "").trim().toLowerCase();
      const knownKeys = new Set(modelInfos.map((info) => info.key));
      state.hiddenModels = new Set(
        [...state.hiddenModels].filter((key) => knownKeys.has(key)),
      );

      const visibleInfos = modelInfos.filter((info) => {
        if (!query) {
          return true;
        }
        return info.label.toLowerCase().includes(query);
      });

      el.modelToggleGrid.innerHTML = visibleInfos
        .map((info) => {
          const isHidden = state.hiddenModels.has(info.key);
          const checked = isHidden ? "" : " checked";
          return `
            <label class="model-toggle-item ${isHidden ? "hidden" : ""}" title="${escapeHtml(isHidden ? "Unchecked (hidden)" : "Checked (shown)")}">
              <input type="checkbox" data-model-key="${escapeHtml(info.key)}"${checked}>
              <span>${escapeHtml(info.label)}</span>
            </label>
          `;
        })
        .join("");

      const hiddenCount = state.hiddenModels.size;
      const totalCount = modelInfos.length;
      const filteredCount = visibleInfos.length;
      const primaryInfo = state.primaryOnly
        ? `Primary set ON (${state.primaryModelKeys.size} models). `
        : `Primary set OFF. `;
      el.modelToggleNote.textContent = `${primaryInfo}Hidden: ${hiddenCount} of ${totalCount}. Showing ${filteredCount} in this list.`;
      updatePrimaryModelsButton();
    }

    function getCategorySelections() {
      const checks = [...document.querySelectorAll('input[name="scoreFilter"]:checked')];
      return new Set(checks.map((node) => node.value));
    }

    function buildScoreFilter() {
      el.scoreFilter.innerHTML = "";
      CATEGORY_ORDER.forEach((key) => {
        const meta = CATEGORY_META[key];
        const label = document.createElement("label");
        label.className = "score-chip";
        label.innerHTML = `
          <span class="dot ${meta.colorClass}"></span>
          <input type="checkbox" name="scoreFilter" value="${key}" checked>
          ${escapeHtml(meta.label)}
        `;
        const input = label.querySelector("input");
        input.addEventListener("change", renderAll);
        el.scoreFilter.appendChild(label);
      });
    }

    function applyFilters(rows) {
      const org = el.filterOrg.value;
      const reasoning = el.filterReasoning.value;
      const technique = el.filterTechnique.value;
      const domain = el.filterDomain.value;
      const query = el.filterQuery.value.trim().toLowerCase();
      const allowedCategories = getCategorySelections();
      const excludedModelKeys = state.hiddenModels;

      return rows.filter((row) => {
        const key = modelKey(row);
        if (org !== "all" && String(row.model_org || "") !== org) {
          return false;
        }
        if (excludedModelKeys.has(key)) {
          return false;
        }
        if (state.primaryOnly && !state.primaryModelKeys.has(key)) {
          return false;
        }
        if (reasoning !== "all" && reasoningFilterLevel(row.model_reasoning_level) !== reasoning) {
          return false;
        }
        if (technique !== "all" && String(row.technique || "") !== technique) {
          return false;
        }
        if (domain !== "all" && String(row.domain || "") !== domain) {
          return false;
        }
        if (!allowedCategories.has(categoryKey(row))) {
          return false;
        }
        if (query) {
          const haystack = [
            displayModel(row),
            row.model || "",
            row.question_id,
            row.question,
            row.technique,
            row.domain,
            row.response_text,
          ]
            .join(" ")
            .toLowerCase();
          if (!haystack.includes(query)) {
            return false;
          }
        }
        return true;
      });
    }

    function pct(value, total) {
      if (!total) {
        return 0;
      }
      return (value / total) * 100;
    }

    function formatPct(value) {
      return `${Number(value).toFixed(1)}%`;
    }

    function aggregateCounts(rows) {
      const counts = { green: 0, amber: 0, red: 0, error: 0 };
      rows.forEach((row) => {
        counts[categoryKey(row)] += 1;
      });
      return counts;
    }

    function renderKpis(filteredRows) {
      const counts = aggregateCounts(filteredRows);
      const total = filteredRows.length;
      const scored = counts.green + counts.amber + counts.red;
      const greenRate = pct(counts.green, scored);
      const amberRate = pct(counts.amber, scored);
      const redRate = pct(counts.red, scored);

      const cards = [
        {
          label: "Visible Rows",
          value: total.toLocaleString(),
          hint: `${scored.toLocaleString()} categorized rows`,
          className: "",
        },
        {
          label: "Green Category",
          value: formatPct(greenRate),
          hint: `${counts.green} rows`,
          className: "green",
        },
        {
          label: "Amber Category",
          value: formatPct(amberRate),
          hint: `${counts.amber} rows`,
          className: "amber",
        },
        {
          label: "Red Category",
          value: formatPct(redRate),
          hint: `${counts.red} rows`,
          className: "red",
        },
        {
          label: "Errors",
          value: counts.error.toLocaleString(),
          hint: "Rows with no usable verdict",
          className: "error",
        },
      ];

      el.kpis.innerHTML = cards
        .map((card) => {
          return `
            <div class="kpi ${card.className}">
              <div class="label">${escapeHtml(card.label)}</div>
              <div class="value">${escapeHtml(card.value)}</div>
              <div class="hint">${escapeHtml(card.hint)}</div>
            </div>
          `;
        })
        .join("");
    }

    function renderScoreMix(filteredRows) {
      const counts = aggregateCounts(filteredRows);
      const total = filteredRows.length || 1;

      const segments = CATEGORY_ORDER
        .map((key) => {
          const width = pct(counts[key], total);
          return `<div class="mix-seg ${CATEGORY_META[key].colorClass}" style="width:${width}%;"></div>`;
        })
        .join("");
      el.scoreMixTrack.innerHTML = segments;

      const labels = CATEGORY_ORDER
        .map((key) => {
          const value = counts[key];
          const percent = pct(value, total);
          return `
            <span class="score-chip">
              <span class="dot ${CATEGORY_META[key].colorClass}"></span>
              ${escapeHtml(CATEGORY_META[key].label)}: ${percent.toFixed(1)}%
            </span>
          `;
        })
        .join("");
      el.scoreMixLabels.innerHTML = labels;
    }

    function groupBy(rows, keyFn) {
      const map = new Map();
      rows.forEach((row) => {
        const key = keyFn(row);
        if (!map.has(key)) {
          map.set(key, []);
        }
        map.get(key).push(row);
      });
      return map;
    }

    function summarizeRows(rows) {
      const counts = aggregateCounts(rows);
      const scored = counts.green + counts.amber + counts.red;
      return {
        counts,
        rows: rows.length,
        scored,
        greenRate: pct(counts.green, scored),
        amberRate: pct(counts.amber, scored),
        redRate: pct(counts.red, scored),
        errorRate: pct(counts.error, rows.length),
      };
    }

    function renderTechniqueBars(filteredRows) {
      const grouped = groupBy(filteredRows, (row) => String(row.technique || "unknown"));
      const data = [...grouped.entries()].map(([technique, rows]) => {
        const stats = summarizeRows(rows);
        return { technique, ...stats };
      });
      data.sort((a, b) => b.greenRate - a.greenRate || a.technique.localeCompare(b.technique));

      el.techniqueBars.innerHTML = data
        .map((item) => {
          return `
            <div class="bar-row">
              <div class="name">${escapeHtml(item.technique)}</div>
              <div class="bar"><span style="width:${item.greenRate.toFixed(2)}%"></span></div>
              <div class="bar-value">${formatPct(item.greenRate)}</div>
            </div>
          `;
        })
        .join("");
    }

    function renderSimpleModelBars(filteredRows) {
      const segmentLabel = (pct) => {
        if (pct >= 10) {
          return `${pct.toFixed(1)}%`;
        }
        if (pct >= 3) {
          return `${Math.round(pct)}%`;
        }
        return "";
      };

      const byModel = groupBy(filteredRows, (row) => modelKey(row));
      const rows = [...byModel.entries()].map(([key, modelRows]) => {
        const stats = summarizeRows(modelRows);
        const sample = modelRows[0] || {};
        const greenPct = stats.greenRate;
        const amberPct = stats.amberRate;
        const redPct = stats.redRate;
        return {
          key,
          label: displayModel(sample),
          rows: modelRows.length,
          detectRate: greenPct,
          scored: stats.scored,
          greenPct,
          amberPct,
          redPct,
        };
      });

      rows.sort((a, b) => b.detectRate - a.detectRate || a.label.localeCompare(b.label));

      el.simpleModelBars.innerHTML = rows
        .map((row, idx) => {
          const rank = idx + 1;
          const selectedCategory = state.chartDrilldown && state.chartDrilldown.modelKey === row.key
            ? state.chartDrilldown.category
            : "";
          const greenSelected = selectedCategory === "green" ? " selected" : "";
          const amberSelected = selectedCategory === "amber" ? " selected" : "";
          const redSelected = selectedCategory === "red" ? " selected" : "";
          return `
            <div class="stack-row">
              <div class="stack-rank">${rank}</div>
              <div class="name">${escapeHtml(row.label)}</div>
              <div class="stack-track">
                <span class="stack-seg green${greenSelected}" data-model-key="${escapeHtml(row.key)}" data-category="green" style="width:${row.greenPct.toFixed(3)}%;" title="${escapeHtml(`Click to view ${row.label} Â· Green (${row.greenPct.toFixed(1)}%)`)}"><span class="seg-label">${escapeHtml(segmentLabel(row.greenPct))}</span></span>
                <span class="stack-seg amber${amberSelected}" data-model-key="${escapeHtml(row.key)}" data-category="amber" style="width:${row.amberPct.toFixed(3)}%;" title="${escapeHtml(`Click to view ${row.label} Â· Amber (${row.amberPct.toFixed(1)}%)`)}"><span class="seg-label">${escapeHtml(segmentLabel(row.amberPct))}</span></span>
                <span class="stack-seg red${redSelected}" data-model-key="${escapeHtml(row.key)}" data-category="red" style="width:${row.redPct.toFixed(3)}%;" title="${escapeHtml(`Click to view ${row.label} Â· Red (${row.redPct.toFixed(1)}%)`)}"><span class="seg-label">${escapeHtml(segmentLabel(row.redPct))}</span></span>
              </div>
            </div>
          `;
        })
        .join("");
    }

    function renderChartDrilldown(filteredRows) {
      if (!el.chartDrilldownPanel || !el.chartDrilldownBody) {
        return;
      }
      const selected = state.chartDrilldown;
      if (!selected || !selected.modelKey || !selected.category || !CATEGORY_META[selected.category]) {
        el.chartDrilldownPanel.classList.add("hidden-block");
        el.chartDrilldownBody.innerHTML = "";
        return;
      }

      const modelSample = filteredRows.find((row) => modelKey(row) === selected.modelKey)
        || state.rows.find((row) => modelKey(row) === selected.modelKey);
      if (!modelSample) {
        state.chartDrilldown = null;
        el.chartDrilldownPanel.classList.add("hidden-block");
        el.chartDrilldownBody.innerHTML = "";
        return;
      }

      const matches = filteredRows
        .filter((row) => modelKey(row) === selected.modelKey && categoryKey(row) === selected.category)
        .sort((a, b) => String(a.question_id || "").localeCompare(String(b.question_id || "")));
      const categoryMeta = CATEGORY_META[selected.category];
      const modelLabel = displayModel(modelSample);
      el.chartDrilldownTitle.textContent = `${modelLabel} Â· ${categoryMeta.label}`;
      el.chartDrilldownMeta.textContent = `${matches.length} matching responses`;

      if (!matches.length) {
        el.chartDrilldownBody.innerHTML = `<p class="subtle">No matching rows under the current filters.</p>`;
      } else {
        el.chartDrilldownBody.innerHTML = matches
          .map((row) => {
            const responseText = row.response_text || row.error || "No response text.";
            const metaBits = [
              row.question_id || "unknown",
              displayTechnique(row.technique || "unknown"),
              row.domain || "unknown",
            ];
            return `
              <article class="drilldown-item">
                <div class="meta">
                  <span class="pill ${categoryMeta.colorClass}">${escapeHtml(categoryMeta.label)}</span>
                  <span>${escapeHtml(metaBits.join(" Â· "))}</span>
                </div>
                <p class="question">${escapeHtml(row.question || "")}</p>
                <p class="response">${escapeHtml(responseText)}</p>
              </article>
            `;
          })
          .join("");
      }
      el.chartDrilldownPanel.classList.remove("hidden-block");
    }

    function defaultLeaderboardCompare(a, b) {
      if (b.greenRate !== a.greenRate) {
        return b.greenRate - a.greenRate;
      }
      if (a.redRate !== b.redRate) {
        return a.redRate - b.redRate;
      }
      return a.model.localeCompare(b.model);
    }

    function updateLeaderboardSortIndicators() {
      const indicators = document.querySelectorAll("[data-sort-ind]");
      indicators.forEach((node) => {
        const key = node.getAttribute("data-sort-ind");
        if (key === state.leaderboardSort.key) {
          node.textContent = state.leaderboardSort.direction === "asc" ? "â–²" : "â–¼";
        } else {
          node.textContent = "";
        }
      });
    }

    function renderLeaderboard(filteredRows) {
      const byModel = groupBy(filteredRows, (row) => modelKey(row));
      const rows = [...byModel.entries()].map(([key, modelRows]) => {
        const sample = modelRows[0] || {};
        const stats = summarizeRows(modelRows);
        return {
          key,
          rank: 0,
          model: displayModel(sample),
          org: String(sample.model_org || "unknown"),
          reasoning: normalizeReasoningLevel(sample.model_reasoning_level),
          ...stats,
        };
      });

      const baseline = [...rows].sort(defaultLeaderboardCompare);
      baseline.forEach((row, idx) => {
        row.rank = idx + 1;
      });

      const { key, direction } = state.leaderboardSort;
      const numericKeys = new Set([
        "rank",
        "greenRate",
        "amberRate",
        "redRate",
        "errorRate",
        "rows",
      ]);
      const dir = direction === "asc" ? 1 : -1;
      baseline.sort((a, b) => {
        let cmp = 0;
        if (numericKeys.has(key)) {
          cmp = Number(a[key] || 0) - Number(b[key] || 0);
        } else {
          cmp = String(a[key] || "").localeCompare(String(b[key] || ""));
        }
        if (cmp !== 0) {
          return cmp * dir;
        }
        return defaultLeaderboardCompare(a, b);
      });

      el.leaderboardBody.innerHTML = baseline
        .map((row) => {
          const mixTotal = row.rows || 1;
          const mix = CATEGORY_ORDER
            .map((key) => {
              return `<span class="mix-seg ${CATEGORY_META[key].colorClass}" style="width:${pct(row.counts[key], mixTotal).toFixed(2)}%;"></span>`;
            })
            .join("");
          const reasoningLabel =
            row.reasoning && row.reasoning !== "none"
              ? row.reasoning.charAt(0).toUpperCase() + row.reasoning.slice(1)
              : "None";
          return `
            <tr>
              <td>${row.rank}</td>
              <td>
                <div class="model-name">${escapeHtml(row.model)}</div>
              </td>
              <td>${escapeHtml(row.org)}</td>
              <td>${escapeHtml(reasoningLabel)}</td>
              <td>${formatPct(row.greenRate)}</td>
              <td>${formatPct(row.amberRate)}</td>
              <td>${formatPct(row.redRate)}</td>
              <td>${formatPct(row.errorRate)}</td>
              <td class="mix-cell">
                <div class="mini-mix">${mix}</div>
              </td>
              <td>${row.rows}</td>
            </tr>
          `;
        })
        .join("");
      updateLeaderboardSortIndicators();
    }

    function questionBandMatches(correctPct, band) {
      const pctValue = Number(correctPct || 0);
      if (band === "80_100") {
        return pctValue >= 80;
      }
      if (band === "60_80") {
        return pctValue >= 60 && pctValue < 80;
      }
      if (band === "40_60") {
        return pctValue >= 40 && pctValue < 60;
      }
      if (band === "20_40") {
        return pctValue >= 20 && pctValue < 40;
      }
      if (band === "0_20") {
        return pctValue < 20;
      }
      return true;
    }

    function getQuestionEntries(filteredRows) {
      return getQuestionGroups(filteredRows, false)
        .map(([questionId, rows]) => {
          const sample = rows[0] || {};
          const stats = summarizeRows(rows);
          return {
            questionId,
            rows,
            sample,
            correctPct: stats.greenRate,
            scored: stats.scored,
            hasGreen: rows.some((row) => categoryKey(row) === "green"),
            hasRed: rows.some((row) => categoryKey(row) === "red"),
          };
        })
        .sort((a, b) =>
          b.correctPct - a.correctPct
          || a.questionId.localeCompare(b.questionId),
        );
    }

    function getBandFilteredQuestionEntries(filteredRows, requirePairs = false) {
      const band = (el.compareQuestionBand && el.compareQuestionBand.value) || "all";
      const entries = getQuestionEntries(filteredRows)
        .filter((entry) => questionBandMatches(entry.correctPct, band));
      if (!requirePairs) {
        return entries;
      }
      return entries.filter((entry) => entry.rows.length >= 2);
    }

    function renderQuestionOptions(filteredRows) {
      const entries = getBandFilteredQuestionEntries(filteredRows, false);
      const prev = el.compareQuestion.value;
      el.compareQuestion.innerHTML = entries
        .map((entry) => {
          const row = entry.sample;
          const label = `${entry.questionId} Â· ${formatPct(entry.correctPct)} correct Â· ${displayTechnique(row.technique)} Â· ${row.domain || "unknown"}`;
          return `<option value="${escapeHtml(entry.questionId)}">${escapeHtml(label)}</option>`;
        })
        .join("");
      if (prev && entries.some((entry) => entry.questionId === prev)) {
        el.compareQuestion.value = prev;
      } else if (entries[0]) {
        el.compareQuestion.value = entries[0].questionId;
      }
    }

    function getQuestionRows(filteredRows) {
      const questionId = el.compareQuestion.value;
      return filteredRows.filter((row) => String(row.question_id || "") === questionId);
    }

    function renderQuestionContext(questionRows) {
      if (!questionRows.length) {
        el.questionContext.innerHTML = `<p class="subtle">No rows match the selected filters for this question.</p>`;
        return;
      }
      const base = questionRows[0];
      el.questionContext.innerHTML = `
        <p class="question">${escapeHtml(base.question || "")}</p>
      `;
    }

    function fillCompareModels(questionRows) {
      const models = collectModelInfos(questionRows);
      const existingA = el.compareModelA.value;
      const existingB = el.compareModelB.value;
      const modelOptions = models
        .map(
          (item) =>
            `<option value="${escapeHtml(item.key)}">${escapeHtml(item.label)}</option>`,
        )
        .join("");
      el.compareModelA.innerHTML = modelOptions;
      el.compareModelB.innerHTML = modelOptions;

      if (models.some((m) => m.key === existingA)) {
        el.compareModelA.value = existingA;
      }
      if (models.some((m) => m.key === existingB)) {
        el.compareModelB.value = existingB;
      }

      const byKey = new Map(questionRows.map((row) => [modelKey(row), row]));
      const pickGreenRedPair = () => {
        const greens = questionRows.filter((row) => categoryKey(row) === "green");
        const reds = questionRows.filter((row) => categoryKey(row) === "red");
        if (greens.length && reds.length) {
          return [greens[0], reds[0]];
        }
        return null;
      };
      const pickBestWorstPair = () => {
        if (questionRows.length < 2) {
          return null;
        }
        const best = [...questionRows].sort((a, b) => categoryRank(categoryKey(b)) - categoryRank(categoryKey(a)))[0];
        const worst = [...questionRows].sort((a, b) => categoryRank(categoryKey(a)) - categoryRank(categoryKey(b)))[0];
        if (best && worst && modelKey(best) !== modelKey(worst)) {
          return [best, worst];
        }
        return null;
      };

      if (!el.compareModelA.value || !el.compareModelB.value) {
        const pair = pickGreenRedPair() || pickBestWorstPair();
        if (pair) {
          el.compareModelA.value = modelKey(pair[0]);
          el.compareModelB.value = modelKey(pair[1]);
        }
      }

      if (!el.compareModelA.value && models.length > 0) {
        el.compareModelA.value = models[0].key;
      }
      if (!el.compareModelB.value) {
        const fallback = models.find((m) => m.key !== el.compareModelA.value);
        el.compareModelB.value = fallback ? fallback.key : (models[0] ? models[0].key : "");
      }
      if (el.compareModelA.value && el.compareModelA.value === el.compareModelB.value && models.length > 1) {
        const fallback = models.find((m) => m.key !== el.compareModelA.value);
        if (fallback) {
          el.compareModelB.value = fallback.key;
        }
      }

      if (!byKey.has(el.compareModelA.value) && models.length > 0) {
        el.compareModelA.value = models[0].key;
      }
      if (!byKey.has(el.compareModelB.value) && models.length > 1) {
        const fallback = models.find((m) => m.key !== el.compareModelA.value);
        el.compareModelB.value = fallback ? fallback.key : models[0].key;
      }
    }

    function renderSingleResponseCard(row, titlePrefix = "") {
      if (!row) {
        return `<div class="response-card error"><p class="subtle">No model selected.</p></div>`;
      }
      const category = categoryKey(row);
      const judgeTooltip = [1, 2, 3]
        .map((idx) => {
          const score = row[`judge_${idx}_score`];
          const just = row[`judge_${idx}_justification`];
          const verdict = CATEGORY_META[categoryFromScore(score)].short;
          if (just) {
            return `J${idx}: ${verdict} - ${just}`;
          }
          return `J${idx}: ${verdict}`;
        })
        .join(" | ");
      const responseText = row.response_text || row.error || "No response text.";
      return `
        <article class="response-card ${CATEGORY_META[category].colorClass}" title="${escapeHtml(judgeTooltip)}">
          <div class="response-head">
            <h4 class="title">${escapeHtml(titlePrefix)}${escapeHtml(displayModel(row))}</h4>
            <span class="pill ${CATEGORY_META[category].colorClass}">${escapeHtml(CATEGORY_META[category].short)}</span>
          </div>
          <p class="response-text">${escapeHtml(responseText)}</p>
        </article>
      `;
    }

    function randomItem(items) {
      if (!items.length) {
        return null;
      }
      return items[Math.floor(Math.random() * items.length)];
    }

    function pickPairFromRows(rows, mode = "any") {
      if (!rows || rows.length < 2) {
        return null;
      }
      const greens = rows.filter((row) => categoryKey(row) === "green");
      const reds = rows.filter((row) => categoryKey(row) === "red");

      if (mode === "green_red" && greens.length && reds.length) {
        const a = randomItem(greens);
        const b = randomItem(reds);
        if (a && b && modelKey(a) !== modelKey(b)) {
          return [a, b];
        }
      }

      if (mode === "green_red") {
        const best = [...rows].sort((a, b) => categoryRank(categoryKey(b)) - categoryRank(categoryKey(a)))[0];
        const worst = [...rows].sort((a, b) => categoryRank(categoryKey(a)) - categoryRank(categoryKey(b)))[0];
        if (best && worst && modelKey(best) !== modelKey(worst)) {
          return [best, worst];
        }
      }

      const i = Math.floor(Math.random() * rows.length);
      let j = Math.floor(Math.random() * rows.length);
      while (j === i && rows.length > 1) {
        j = Math.floor(Math.random() * rows.length);
      }
      if (rows[i] && rows[j] && modelKey(rows[i]) !== modelKey(rows[j])) {
        return [rows[i], rows[j]];
      }
      const fallback = rows.filter((row) => modelKey(row) !== modelKey(rows[i]));
      if (fallback.length) {
        return [rows[i], fallback[0]];
      }
      return null;
    }

    function getQuestionGroups(sourceRows, requirePairs = false) {
      const groups = new Map();
      sourceRows.forEach((row) => {
        if (!row.question_id) {
          return;
        }
        if (!groups.has(row.question_id)) {
          groups.set(row.question_id, []);
        }
        groups.get(row.question_id).push(row);
      });
      const entries = [...groups.entries()];
      if (!requirePairs) {
        return entries;
      }
      return entries.filter(([, rows]) => rows.length >= 2);
    }

    function applyQuestionSelection(questionId, rows, pairMode = "any") {
      if (!questionId) {
        return false;
      }
      el.compareQuestion.value = questionId;
      const pair = pickPairFromRows(rows, pairMode) || pickPairFromRows(rows, "any");
      if (pair) {
        el.compareModelA.value = modelKey(pair[0]);
        el.compareModelB.value = modelKey(pair[1]);
      }
      renderAll();
      return true;
    }

    function randomizeQuestionPair(mode = "any") {
      const candidates = getBandFilteredQuestionEntries(state.filteredRows || [], true).filter((entry) => {
        if (mode !== "green_red") {
          return true;
        }
        return entry.hasGreen && entry.hasRed;
      });
      if (!candidates.length) {
        return;
      }

      const selected = randomItem(candidates);
      if (!selected) {
        return;
      }
      if (!applyQuestionSelection(selected.questionId, selected.rows, mode)) {
        return;
      }
    }

    function randomizeRankedQuestion(mode = "best") {
      const candidates = getBandFilteredQuestionEntries(state.filteredRows || [], true)
        .filter((entry) => entry.scored > 0)
        .map((entry) => {
          const stats = summarizeRows(entry.rows);
          return {
            questionId: entry.questionId,
            rows: entry.rows,
            greenRate: stats.greenRate,
            redRate: stats.redRate,
            amberRate: stats.amberRate,
            scored: stats.scored,
          };
        });
      if (!candidates.length) {
        return;
      }

      if (mode === "worst") {
        candidates.sort((a, b) =>
          b.redRate - a.redRate
          || a.greenRate - b.greenRate
          || b.scored - a.scored
          || a.questionId.localeCompare(b.questionId),
        );
      } else {
        candidates.sort((a, b) =>
          b.greenRate - a.greenRate
          || a.redRate - b.redRate
          || b.scored - a.scored
          || a.questionId.localeCompare(b.questionId),
        );
      }

      const bucketSize = Math.max(1, Math.min(12, Math.ceil(candidates.length * 0.2)));
      const pool = candidates.slice(0, bucketSize);
      const selected = randomItem(pool);
      if (!selected) {
        return;
      }
      applyQuestionSelection(
        selected.questionId,
        selected.rows,
        mode === "worst" ? "green_red" : "any",
      );
    }

    function renderCompareSection(filteredRows) {
      renderQuestionOptions(filteredRows);
      const questionRows = getQuestionRows(filteredRows);
      state.questionRows = questionRows;
      renderQuestionContext(questionRows);
      fillCompareModels(questionRows);
      const viewMode = el.compareViewMode.value || "pair";
      const showAll = viewMode === "all";

      const questionEntries = getBandFilteredQuestionEntries(filteredRows, false);
      const hasAnyQuestion = questionEntries.length > 0;
      const hasAnyPair = questionEntries.some((entry) => entry.rows.length >= 2);
      const hasGreenRedPair = questionEntries.some((entry) => entry.rows.length >= 2 && entry.hasGreen && entry.hasRed);
      el.randomPairBtn.disabled = !hasAnyPair;
      el.randomGreenRedBtn.disabled = !hasGreenRedPair;
      el.randomBestQuestionBtn.disabled = !hasAnyPair;
      el.randomWorstQuestionBtn.disabled = !hasAnyPair;

      const byModel = new Map();
      questionRows.forEach((row) => byModel.set(modelKey(row), row));
      el.compareModelA.disabled = showAll;
      el.compareModelB.disabled = showAll;

      const rowA = byModel.get(el.compareModelA.value);
      const rowB = byModel.get(el.compareModelB.value);
      if (showAll) {
        el.pairGrid.classList.add("hidden-block");
        const sortedRows = [...questionRows].sort((a, b) => {
          const rankCmp = categoryRank(categoryKey(b)) - categoryRank(categoryKey(a));
          if (rankCmp !== 0) {
            return rankCmp;
          }
          return displayModel(a).localeCompare(displayModel(b));
        });
        el.allResponsesGrid.classList.remove("hidden-block");
        el.allResponsesGrid.innerHTML = sortedRows.length
          ? sortedRows.map((row) => renderSingleResponseCard(row)).join("")
          : `<div class="response-card error"><p class="subtle">No responses for this question.</p></div>`;
      } else {
        el.allResponsesGrid.classList.add("hidden-block");
        el.allResponsesGrid.innerHTML = "";
        el.pairGrid.classList.remove("hidden-block");
        el.modelACard.innerHTML = renderSingleResponseCard(rowA, "A Â· ");
        el.modelBCard.innerHTML = renderSingleResponseCard(rowB, "B Â· ");
      }
    }

    function refreshFilterOptions() {
      fillSelect(el.filterOrg, uniqSorted(state.rows.map((r) => r.model_org || "unknown")));
      const modelInfos = collectModelInfos(state.rows);
      renderModelToggleGrid(modelInfos);
      fillSelect(el.filterReasoning, uniqSorted(state.rows.map((r) => reasoningFilterLevel(r.model_reasoning_level))));
      fillSelect(
        el.filterTechnique,
        uniqSorted(state.rows.map((r) => r.technique || "unknown")),
        "all",
        displayTechnique,
      );
      fillSelect(el.filterDomain, uniqSorted(state.rows.map((r) => r.domain || "unknown")));
    }

    function renderAll() {
      if (!state.rows.length) {
        return;
      }
      const filteredRows = applyFilters(state.rows);
      state.filteredRows = filteredRows;
      setDataState(`Showing ${filteredRows.length} of ${state.rows.length} rows.`);
      renderSimpleModelBars(filteredRows);
      renderChartDrilldown(filteredRows);
      renderLeaderboard(filteredRows);
      renderCompareSection(filteredRows);
    }

    function ingestData(payload) {
      state.responses = payload.responses;
      state.collectionStats = payload.collectionStats;
      state.panelSummary = payload.panelSummary;
      state.aggregateSummary = payload.aggregateSummary;
      state.aggregateRows = payload.aggregateRows;
      state.rows = normalizeRows(payload.aggregateRows, payload.responses);
      state.bySampleId = new Map(state.rows.map((row) => [row.sample_id, row]));
      refreshJudgeFilterLabels();
      state.primaryModelKeys = computePrimaryModelKeys(state.rows);
      refreshFilterOptions();
      renderAll();
    }

    async function loadDefaultData() {
      const paths = resolvedDefaultPaths();
      try {
        const required = await Promise.all([
          fetchText(paths.responses),
          fetchText(paths.collectionStats),
          fetchText(paths.panelSummary),
          fetchText(paths.aggregateSummary),
        ]);

        let aggregateRowsText = "";
        try {
          aggregateRowsText = await fetchText(paths.aggregateRows);
        } catch (error) {
          setDataState("Loaded core files. Aggregate rows are missing, so comparison detail is limited.");
        }

        const payload = {
          responses: parseJsonl(required[0], "responses.jsonl"),
          collectionStats: JSON.parse(required[1]),
          panelSummary: JSON.parse(required[2]),
          aggregateSummary: JSON.parse(required[3]),
          aggregateRows: aggregateRowsText ? parseJsonl(aggregateRowsText, "aggregate.jsonl") : [],
        };
        ingestData(payload);
        setDataState(`Loaded ${payload.responses.length} responses.`);
      } catch (error) {
        setDataState(`Could not load benchmark files: ${error.message}`);
      }
    }

    function resetFilters() {
      el.filterOrg.value = "all";
      el.filterReasoning.value = "all";
      el.filterTechnique.value = "all";
      el.filterDomain.value = "all";
      el.judge1Toggle.checked = true;
      el.judge2Toggle.checked = true;
      if (!el.judge3Toggle.disabled) {
        el.judge3Toggle.checked = true;
      }
      syncSelectedJudgesFromUI();
      state.hiddenModels.clear();
      state.primaryOnly = false;
      el.filterModelToggleSearch.value = "";
      el.filterQuery.value = "";
      [...document.querySelectorAll('input[name="scoreFilter"]')].forEach((node) => {
        node.checked = true;
      });
      state.primaryModelKeys = computePrimaryModelKeys(state.rows);
      renderModelToggleGrid(collectModelInfos(state.rows));
      renderAll();
    }

    function bindEvents() {
      el.clearFiltersBtn.addEventListener("click", resetFilters);
      el.primaryModelsBtn.addEventListener("click", () => {
        state.primaryOnly = !state.primaryOnly;
        renderModelToggleGrid(collectModelInfos(state.rows));
        renderAll();
      });
      el.showAllModelsBtn.addEventListener("click", () => {
        state.hiddenModels.clear();
        renderModelToggleGrid(collectModelInfos(state.rows));
        renderAll();
      });
      el.hideAllModelsBtn.addEventListener("click", () => {
        collectModelInfos(state.rows).forEach((info) => state.hiddenModels.add(info.key));
        renderModelToggleGrid(collectModelInfos(state.rows));
        renderAll();
      });
      el.filterModelToggleSearch.addEventListener("input", () => {
        renderModelToggleGrid(collectModelInfos(state.rows));
      });
      [1, 2, 3].forEach((judgeIndex) => {
        const toggle = el[`judge${judgeIndex}Toggle`];
        toggle.addEventListener("change", () => {
          syncSelectedJudgesFromUI(judgeIndex);
          state.primaryOnly = false;
          state.chartDrilldown = null;
          state.hiddenModels.clear();
          el.filterModelToggleSearch.value = "";
          el.filterQuery.value = "";
          [...document.querySelectorAll('input[name="scoreFilter"]')].forEach((node) => {
            node.checked = true;
          });
          state.primaryModelKeys = computePrimaryModelKeys(state.rows);
          renderModelToggleGrid(collectModelInfos(state.rows));
          renderAll();
        });
      });
      el.modelToggleGrid.addEventListener("change", (event) => {
        const input = event.target;
        if (!(input instanceof HTMLInputElement) || input.type !== "checkbox") {
          return;
        }
        const key = String(input.getAttribute("data-model-key") || "");
        if (!key) {
          return;
        }
        if (input.checked) {
          state.hiddenModels.delete(key);
        } else {
          state.hiddenModels.add(key);
        }
        renderModelToggleGrid(collectModelInfos(state.rows));
        renderAll();
      });
      el.randomPairBtn.addEventListener("click", () => {
        randomizeQuestionPair("any");
      });
      el.randomGreenRedBtn.addEventListener("click", () => {
        randomizeQuestionPair("green_red");
      });
      el.randomBestQuestionBtn.addEventListener("click", () => {
        randomizeRankedQuestion("best");
      });
      el.randomWorstQuestionBtn.addEventListener("click", () => {
        randomizeRankedQuestion("worst");
      });
      el.simpleModelBars.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof Element)) {
          return;
        }
        const segment = target.closest(".stack-seg[data-model-key][data-category]");
        if (!segment) {
          return;
        }
        const selectedModelKey = String(segment.getAttribute("data-model-key") || "");
        const selectedCategory = String(segment.getAttribute("data-category") || "");
        if (!selectedModelKey || !CATEGORY_META[selectedCategory]) {
          return;
        }
        const isSameSelection = state.chartDrilldown
          && state.chartDrilldown.modelKey === selectedModelKey
          && state.chartDrilldown.category === selectedCategory;
        state.chartDrilldown = isSameSelection
          ? null
          : { modelKey: selectedModelKey, category: selectedCategory };
        renderAll();
      });
      el.clearChartDrilldownBtn.addEventListener("click", () => {
        state.chartDrilldown = null;
        renderAll();
      });
      const headerCells = el.leaderboardHead.querySelectorAll("th.sortable-th");
      headerCells.forEach((node) => {
        node.addEventListener("click", () => {
          const key = String(node.getAttribute("data-sort-key") || "");
          if (!key) {
            return;
          }
          if (state.leaderboardSort.key === key) {
            state.leaderboardSort.direction =
              state.leaderboardSort.direction === "asc" ? "desc" : "asc";
          } else {
            state.leaderboardSort.key = key;
            state.leaderboardSort.direction = key === "model" || key === "org" || key === "reasoning" ? "asc" : "desc";
          }
          renderAll();
        });
      });
      [
        el.filterOrg,
        el.filterReasoning,
        el.filterTechnique,
        el.filterDomain,
        el.filterQuery,
        el.compareQuestion,
        el.compareQuestionBand,
        el.compareModelA,
        el.compareModelB,
        el.compareViewMode,
      ].forEach((node) => {
        node.addEventListener("change", renderAll);
        if (node.tagName === "INPUT") {
          node.addEventListener("input", renderAll);
        }
      });
    }

    function bootstrap() {
      cacheElements();
      syncSelectedJudgesFromUI();
      buildScoreFilter();
      bindEvents();
      loadDefaultData();
    }

    bootstrap();
  </script>
</body>
</html>
